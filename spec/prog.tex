\chapter{Program structure}
\label{programchapter}

\section{Programs}

A Scheme program consists of a sequence of 
\defining{program parts}: expressions, definitions, syntax definitions,
record-type definitions, imports, and includes.  A collection of program
parts may be encapsulated in a module to be reused by multiple
programs.
Expressions are described in chapter~\ref{expressionchapter};
the other program parts, as well as modules, are the subject of the
rest of the present chapter.

Programs are typically stored in files or entered interactively to a
running Scheme system, although other paradigms are possible;
questions of user interface lie outside the scope of this report.
(Indeed, Scheme would still be useful as a notation for expressing
computational methods even in the absence of a mechanical
implementation.)

Program parts other than expressions that are present
at the top level of a program can be interpreted declaratively.
They cause bindings to be created in the top level
environment or modify the value of existing top-level bindings.
Expressions occurring at the top level of a program are
interpreted imperatively; they are executed in order when the program is
invoked or loaded, and typically perform some kind of initialization.

At the top level of a program {\tt(begin \hyperi{form} \dotsfoo)} is
equivalent to the sequence of expressions, definitions, and syntax definitions
that form the body of the \ide{begin}.

\todo{Cromarty, etc.: disclaimer about top level?}

\section{Definitions}
\label{defines}

Definitions are valid in some, but not all, contexts where expressions
are allowed.  They are valid only at the top level of a \hyper{program}
and at the beginning of a \hyper{body}.
\mainindex{definition}

A definition should have one of the following forms:\mainschindex{define}

\begin{itemize}

\item{\tt(define \hyper{variable} \hyper{expression})}

\item{\tt(define (\hyper{variable} \hyper{formals}) \hyper{body})}

\hyper{Formals} should be either a
sequence of zero or more variables, or a sequence of one or more
variables followed by a space-delimited period and another variable (as
in a lambda expression).  This form is equivalent to
\begin{scheme}
(define \hyper{variable}
  (lambda (\hyper{formals}) \hyper{body}))\rm.%
\end{scheme}

\item{\tt(define (\hyper{variable} .\ \hyper{formal}) \hyper{body})}

\hyper{Formal} should be a single
variable.  This form is equivalent to
\begin{scheme}
(define \hyper{variable}
  (lambda \hyper{formal} \hyper{body}))\rm.%
\end{scheme}

\end{itemize}

\subsection{Top level definitions}

At the top level of a program, a definition
\begin{scheme}
(define \hyper{variable} \hyper{expression})%
\end{scheme}
has essentially the same effect as the assignment expression
\begin{scheme}
(\ide{set!}\ \hyper{variable} \hyper{expression})%
\end{scheme}
if \hyper{variable} is bound.  If \hyper{variable} is not bound,
however, then the definition will bind \hyper{variable} to a new
location before performing the assignment, whereas it would be an error
to perform a {\cf set!}\ on an unbound\index{unbound} variable.

\begin{scheme}
(define add3
  (lambda (x) (+ x 3)))
(add3 3)                            \ev  6
(define first car)
(first '(1 2))                      \ev  1%
\end{scheme}

Some implementations of Scheme use an initial environment in
which all possible variables are bound to locations, most of
which contain undefined values.  Top level definitions in
such an implementation are truly equivalent to assignments.

\todo{Rozas: equal time for opposition semantics?}


\subsection{Internal definitions}
\label{internaldefines}

Definitions may occur at the
beginning of a \hyper{body} (that is, the body of a \ide{lambda},
\ide{let}, \ide{let*}, \ide{letrec}, \ide{letrec*}, \ide{let-syntax},
or \ide{letrec-syntax}
expression or that of a definition of an appropriate form).
Such definitions are known as {\em internal definitions} \mainindex{internal
definition} as opposed to the top level definitions described above.
The variable defined by an internal definition is local to the
\hyper{body}.  That is, \hyper{variable} is bound rather than assigned,
and the region of the binding is the entire \hyper{body}.  For example,

\begin{scheme}
(let ((x 5))
  (define foo (lambda (y) (bar x y)))
  (define bar (lambda (a b) (+ (* a b) a)))
  (foo (+ x 3)))                \ev  45%
\end{scheme}

A \hyper{body} containing internal definitions can always be converted
into a completely equivalent {\cf letrec*} expression.  For example, the
{\cf let} expression in the above example is equivalent to

\begin{scheme}
(let ((x 5))
  (letrec* ((foo (lambda (y) (bar x y)))
            (bar (lambda (a b) (+ (* a b) a))))
    (foo (+ x 3))))%
\end{scheme}

Just as for the equivalent {\cf letrec*} expression, it must be
possible to evaluate each \hyper{expression} of every internal
definition in a \hyper{body} without assigning or referring to
the value of the corresponding \hyper{variable} or the \hyper{variable}
of any of the definitions that follow it in \hyper{body}.

Wherever an internal definition may occur
{\tt(begin \hyperi{definition} \dotsfoo)}
is equivalent to the sequence of definitions
that form the body of the \ide{begin}.

\section{Syntax definitions}

Syntax definitions are valid wherever definitions are.
\mainindex{syntax definition}
They have the following form:\mainschindex{define-syntax}

{\tt(define-syntax \hyper{keyword} \hyper{transformer spec})}

\hyper{Keyword} is an identifier, and
the \hyper{transformer spec} should be an instance of \ide{syntax-rules}.
If the {\cf define-syntax} occurs at the top-level, then the top-level
syntactic environment is extended by binding the
\hyper{keyword} to the specified transformer.  Otherwise, it is an
{\em internal syntax definition}, and is local to the \hyper{body} in which
it is defined.
Any {\em internal syntax definitions} in a body must come before any
{\em internal definitions}.

\begin{scheme}
(let ((x 1) (y 2))
  (define-syntax swap!
    (syntax-rules ()
      ((swap! a b)
       (let ((tmp a))
         (set! a b)
         (set! b tmp)))))
  (swap! x y)
  (list x y))                \ev (2 1)%
\end{scheme}

%There is no {\cf define-syntax} analogue of internal definitions.

%[Rationale flushed because it may or may not be true and isn't the
% real rationale anyway. -RK]
%\begin{rationale}
%As discussed below, the syntax and scope rules for syntax definitions
%can give rise to syntactic ambiguities when syntactic keywords are
%shadowed.
%Further ambiguities would arise if {\cf define-syntax}
%were permitted at the beginning of a \meta{body}, with scope
%rules analogous to those for internal definitions.
%\end{rationale}

% It is an error for a program to contain more than one top-level
% \meta{definition} or \meta{syntax definition} of any identifier.
%
% [I flushed this because it isn't an error for a program to
% contain more than one top-level definition of an identifier,
% and I didn't want to introduce any gratuitous incompatibilities
% with the existing Scheme language. -- Will]

Although macros may expand into definitions and syntax definitions in
any context that permits them, it is an error for a definition or syntax
definition to shadow a syntactic keyword whose meaning is needed to
determine whether some form in the group of forms that contains the
shadowing definition is in fact a definition, or, for internal definitions,
is needed to determine the boundary between the group and the expressions
that follow the group.  For example, the following are errors:

\begin{scheme}
(define define 3)

(begin (define begin list))

(let-syntax
  ((foo (syntax-rules ()
          ((foo (proc args ...) body ...)
           (define proc
             (lambda (args ...)
               body ...))))))
  (let ((x 3))
    (foo (plus x y) (+ x y))
    (define foo x)
    (plus foo x)))
\end{scheme}

\section{Record-type definitions}
\label{usertypes}

This section describes syntax for creating new data types, called
record types.  A predicate, constructor, and field accessors and
modifiers are defined for each record type.

\begin{entry}{%
\proto{define-record-type}{ name constructor pred field \dotsfoo}{syntax}}

\syntax
\hyper{name} and \hyper{pred} should be identifiers.
The \hyper{constructor} should be of the form
\begin{scheme}
(\hyper{constructor name} \hyper{field name} \dotsfoo)%
\end{scheme}
and each \hyper{field} should be of the form
\begin{scheme}
(\hyper{field name} \hyper{accessor name})%
\end{scheme}
\begin{scheme}
$|$ (\hyper{field name} \hyper{accessor name} \hyper{modifier name})%
\end{scheme}

{\cf define-record-type} is generative: each use creates a new record
type that is distinct from all existing types, including other record
types and Scheme's predefined types.

An instance of {\cf define-record-type} is equivalent to the following
definitions:

\begin{itemize}

\item \hyper{name} is bound to a representation of the record type
  itself, possibly as a syntactic form.

\item \hyper{constructor name} is bound to a procedure that takes as
  many arguments as there are \hyper{field name}s in the
  \texttt{(\hyper{constructor name} \dotsfoo)} subform and returns a
  new record of type \hyper{name}.  Fields whose names are listed with
  \hyper{constructor name} have the corresponding argument as their
  initial value.  The initial values of all other fields are
  unspecified.

\item \hyper{pred} is a predicate that returns \schtrue{} when given a
  value returned by \hyper{constructor name} and \schfalse{} for
  everything else.

\item Each \hyper{accessor name} is a procedure that takes a record of
  type \hyper{name} and returns the current value of the corresponding
  field.  It is an error to pass an accessor a value which is not a
  record of the appropriate type.

\item Each \hyper{modifier name} is a procedure that takes a record of
  type \hyper{name} and a value which becomes the new value of the
  corresponding field; an unspecified value is returned.  It is an
  error to pass a modifier a first argument which is not a record of
  the appropriate type.

\end{itemize}

The following

\begin{scheme}
(define-record-type <pare>
  (kons x y)
  pare?
  (x kar set-kar!)
  (y kdr))
\end{scheme}

defines {\cf kons} to be a constructor, {\cf kar} and {\cf kdr}
to be accessors, {\cf set-kar!} to be a modifier, and {\cf pare?}
to be a predicate for instances of {\cf <pare>}.

\begin{scheme}
  (pare? (kons 1 2))        \ev \schtrue
  (pare? (cons 1 2))        \ev \schfalse
  (kar (kons 1 2))          \ev 1
  (kdr (kons 1 2))          \ev 2
  (let ((k (kons 1 2)))
    (set-kar! k 3)
    (kar k))                \ev 3
\end{scheme}

\end{entry}


\section{Modules}

Modules provide a way to encapsulate programs and manage the top-level
namespace.  This section defines the notation and semantics for modules.

\subsection{Module Syntax}

A module definition takes the following form:

\begin{scheme}
(module \hyper{module name}
  \hyper{module declaration} \dotsfoo)
\end{scheme}

\hyper{module name} is a list of identifiers or exact integers used to
identify the module uniquely when importing from other programs or
modules.

A \hyper{module declaration} can be any of:

\begin{itemize}

\item{\tt(export \hyper{export spec} \dotsfoo)}

\item{\tt(import \hyper{import set} \dotsfoo)}

\item{\tt(begin \hyper{command or definition} \dotsfoo)}

\item{\tt(include \hyper{$filename_1$} \hyper{$filename_2$} \dotsfoo)}

\item{\tt(include-ci \hyper{$filename_1$} \hyper{$filename_2$} \dotsfoo)}

\item{\tt(cond-expand \hyper{cond-expand clause} \dotsfoo)}

\end{itemize}

An \ide{export} declaration specifies a list of identifiers which
may be made visible to other modules or programs.  An
\hyper{export spec} must have one of the following forms:

\begin{itemize}
\item{\hyper{identifier}}
\item{\tt{(rename \hyper{$identifier_1$} \hyper{$identifier_2$})}}
\end{itemize}

In an \hyper{export spec}, an \hyper{identifier} names a single
binding defined within or imported into the library, where the
external name for the export is the same as the name of the binding
within the library. A rename spec exports the binding named by
\hyper{$identifier_1$} in each
{\tt(\hyper{$identifier_1$} \hyper{$identifier_2$})} pairing,
using \hyper{$identifier_2$} as the external name.

An \ide{import} declaration provides a way to import the identifiers
exported by a module.  Each \hyper{import set} names a set of bindings
from another module and possibly specifies local names for the
imported bindings. It must be one of the following:

\begin{itemize}
\item {\tt\hyper{module name}}
\item {\tt(only \hyper{import set} \hyper{identifier} \dotsfoo)}
\item {\tt(except \hyper{import set} \hyper{identifier} \dotsfoo)}
\item {\tt(prefix \hyper{import set} \hyper{identifier})}
\item {\tt(rename \hyper{import set} (\hyper{$identifier_1$} \hyper{$identifier_2$}) \dotsfoo)}
\end{itemize}

In the first form, all of the identifiers in the named module's export
clauses are imported with the same names (or the exported names if
exported with a \ide{rename} form).  The additional \hyper{import set}
forms modify this set as follows:

\begin{itemize}

\item An \ide{only} form produces a subset of the given
  \hyper{import set}, including only the listed identifiers (after any
  renaming).  It is an error if any of the listed identifiers are
  not found in the original set.

\item An \ide{except} form produces a subset of the given
  \hyper{import set}, excluding the listed identifiers (after any
  renaming). It is an error if any of the listed identifiers are not
  found in the original set.

\item A \ide{rename} form modifies the given \hyper{import set},
  replacing each instance of \hyper{$identifier_1$} with
  \hyper{$identifier_2$}. It is an error if any of the listed
  \hyper{$identifier_1$}s are not found in the original set.

\item A \ide{prefix} form automatically renames all identifiers in
  the given \hyper{import set}, prefixing each with the specified
  \hyper{identifier}.

\end{itemize}

\ide{import} declarations may also be made at the top-level of a
program.  In a module declaration, the same identifier may not be
imported more than once with different bindings.

The \ide{begin}, \ide{include}, and \ide{include-ci} declarations are
used to specify the commands and definitions that make up the body of
the module.  \ide{begin} takes a list of forms to be spliced
literally, analogous to the top-level \ide{begin}.  \ide{include} and
\ide{include-ci} both take one or more filenames, read all top-level
forms from the files and include the results into the module body as
though wrapped in a \ide{begin}.  \ide{include-ci} uses a case-folding
reader when reading the forms from the file.

The forms from all \ide{begin}, \ide{include}, and \ide{include-ci}
declarations are expanded in the order in which they occur in the
module declaration.

The \ide{cond-expand} module declaration provides a way to statically
expand different module declarations depending on the platform
or implementation under which the module is being loaded.  A
\hyper{cond-expand clause} must be of the following form:

{\tt(\hyper{feature requirement} \hyper{module declaration} \dotsfoo)}

The last clause may be an ``else clause,'' which has the form

{\tt(else \hyper{module declaration} \dotsfoo)}

A \hyper{feature requirement} must be one of the following forms:

\begin{itemize}
\item {\tt\hyper{feature identifier}}
\item {\tt(module \hyper{module name})}
\item {\tt(and \hyper{feature requirement} \dotsfoo)}
\item {\tt(or \hyper{feature requirement} \dotsfoo)}
\item {\tt(not \hyper{feature requirement})}
\end{itemize}

Each implementation maintains a list of feature identifiers which are
present, as well as a list of modules which can be imported.  The
value of a \hyper{feature requirement} can be determined by replacing
each \hyper{feature identifier} and {\tt(module \hyper{module name})}
on the implementation's lists with \schtrue, and all other feature
identifiers and module names with \schfalse, then evaluating the
resulting expression as a Scheme boolean expression under the normal
interpretation of {\cf and}, {\cf or}, and {\cf not}.

A \ide{cond-expand} form is then expanded by evaluating the
\hyper{feature requirement}s of successive \hyper{cond-expand clause}
in order, until one of them returns \schtrue.  When a true clause is
found, the corresponding \hyper{module declaration}s are spliced into
the current module definition and the remaining clauses are ignored.
If none of the \hyper{feature requirement}s evaluate to \schtrue, then
if there is an \ide{else} clause its \hyper{module declaration}s are
included, otherwise the \ide{cond-expand} has no effect.

The exact features provided are implementation-defined, but for
portability a set of recommended features is given in
appendix~\ref{stdfeatures}.

\subsection{Module Examples}

\begin{scheme}

(module (stack)
  (export make push! pop! empty!)
  (import (scheme base))
  (begin
   (define (make) (list กว()))
   (define (push! s v)
     (set-car! s (cons v (car s))))
   (define (pop! s) (let ((v (caar s)))
                      (set-car! s (cdar s))
                      v))
   (define (empty! s) (set-car! s กว()))))

(module (balloons)
  (export make push pop)
  (import (scheme base))
  (begin
   (define (make w h) (cons w h))
   (define (push b amt)
     (cons (- (car b) amt) (+ (cdr b) amt)))
   (define (pop b) (display "Boom! ") 
                   (display (* (car b) (cdr b))) 
                   (newline))))

(module (party)
  ;; Total exports:
  ;; make, push, push!, make-party, pop!
  (export (rename (balloon:make make)
                  (balloon:push push))
          push!
          make-party
          (rename (party-pop! pop!)))
  (import
   (scheme base)
   (only (stack) make push! pop!) ; not empty!
   (prefix (balloons) balloon:))
  (begin
   ;; Creates a party as a stack of balloons,
   ;; starting with two balloons
   (define (make-party)
     (let ((s (make))) ; from stack
       (push! s (balloon:make 10 10))
       (push! s (balloon:make 12 9))
       s))
   (define (party-pop! p)
     (balloon:pop (pop! p)))))

(module (main)
  (export)
  (import (scheme base) (party))
  (begin
   (define p (make-party))
   (pop! p)        ; displays "Boom! 108"
   (push! p (push (make 5 5) 1))
   (pop! p)))      ; displays "Boom! 24"

\end{scheme}
