\chapter{Program structure}
\label{programchapter}

\section{Programs}

A Scheme program consists of a sequence of 
\defining{program parts}: expressions, definitions, syntax definitions,
record type definitions, imports, cond-expands, and includes.  A collection of program
parts may be encapsulated in a library to be reused by multiple
programs.
Expressions are described in chapter~\ref{expressionchapter};
the other program parts, as well as libraries, are the subject of the
rest of the present chapter.

Programs and libraries are typically stored in files, although programs
can be entered interactively to a running Scheme system, and other
paradigms are possible.
Implementations which store libraries in files should document the
mapping from the name of a library to its location in the file system.

Program parts other than expressions that are present
at the top level of a program can be interpreted declaratively.
They cause bindings to be created in the top level
environment or modify the value of existing top-level bindings.
The initial (or
``top level'') Scheme environment is empty except for {\cf import},
so further bindings can only be introduced with {\cf import}.

Expressions occurring at the top level of a program are
interpreted imperatively; they are executed in order when the program is
invoked or loaded, and typically perform some kind of initialization.

At the top level of a program {\tt(begin \hyperi{form} \dotsfoo)} is
equivalent to the sequence of expressions, definitions, and syntax definitions
in the \ide{begin}.   Macros can expand into such {\cf begin}s.

Implementations may provide an interactive session called a
\defining{REPL} (Read-Eval-Print Loop), where Scheme program parts can be
entered and evaluated one at a time.  For convenience and ease of use,
the ``top-level'' Scheme environment in a REPL
must not be not empty, but must start out with a number of variables
bound to locations containing at least the bindings provided by the
base library.  This library includes the core syntax of Scheme
and generally useful procedures that manipulate data.  For example, the
variable {\cf abs} is bound to a
procedure of one argument that computes the absolute value of a
number, and the variable {\cf +} is bound to a procedure that computes
sums.  The full list of {\cf(scheme base)} bindings can be found in
Appendix~\ref{stdlibraries}.


\section{Definitions}
\label{defines}

Definitions are valid in some, but not all, contexts where expressions
are allowed.  They are valid only at the top level of a \hyper{program}
and at the beginning of a \hyper{body}.
\mainindex{definition}

In a \hyper{body} {\tt(begin \hyperi{definition} \dotsfoo)} is equivalent
to the sequence of definitions \hyperi{definition} \dotsfoo. Macros can
expand into such {\cf begin}s.

A definition takes one of the following forms:\mainschindex{define}

\begin{itemize}

\item{\tt(define \hyper{variable} \hyper{expression})}

\item{\tt(define (\hyper{variable} \hyper{formals}) \hyper{body})}

\hyper{Formals} should be either a
sequence of zero or more variables, or a sequence of one or more
variables followed by a space-delimited period and another variable (as
in a lambda expression).  This form is equivalent to
\begin{scheme}
(define \hyper{variable}
  (lambda (\hyper{formals}) \hyper{body}))\rm.%
\end{scheme}

\item{\tt(define (\hyper{variable} .\ \hyper{formal}) \hyper{body})}

\hyper{Formal} should be a single
variable.  This form is equivalent to
\begin{scheme}
(define \hyper{variable}
  (lambda \hyper{formal} \hyper{body}))\rm.%
\end{scheme}

\end{itemize}

\subsection{Top level definitions}

At the top level of a program, a definition
\begin{scheme}
(define \hyper{variable} \hyper{expression})%
\end{scheme}
has essentially the same effect as the assignment expression
\begin{scheme}
(\ide{set!}\ \hyper{variable} \hyper{expression})%
\end{scheme}
if \hyper{variable} is bound to a non-syntax value.  However, if
\hyper{variable} is not bound, 
or is bound to a {\em syntax definition} (see below),
then the definition will bind
\hyper{variable} to a new location before performing the assignment,
whereas it would be an error to perform a {\cf set!}\ on an
unbound\index{unbound} variable.

\begin{scheme}
(define add3
  (lambda (x) (+ x 3)))
(add3 3)                            \ev  6
(define first car)
(first '(1 2))                      \ev  1%
\end{scheme}

Implementations are permitted to provide an initial environment in
which all possible variables are bound to locations, most of
which contain unspecified values.  Top level definitions in
such an implementation are truly equivalent to assignments.



\subsection{Internal definitions}
\label{internaldefines}

Definitions may occur at the
beginning of a \hyper{body} (that is, the body of a \ide{lambda},
\ide{let}, \ide{let*}, \ide{letrec}, \ide{letrec*},
\ide{let-values}, \ide{let-values*}, \ide{let-syntax}, \ide{letrec-syntax},
\ide{parameterize}, \ide{guard}, or \ide{case-lambda}
expression or that of a definition of an appropriate form).
Such definitions are known as {\em internal definitions} \mainindex{internal
definition} as opposed to the top level definitions described above.
The variable defined by an internal definition is local to the
\hyper{body}.  That is, \hyper{variable} is bound rather than assigned,
and the region of the binding is the entire \hyper{body}.  For example,

\begin{scheme}
(let ((x 5))
  (define foo (lambda (y) (bar x y)))
  (define bar (lambda (a b) (+ (* a b) a)))
  (foo (+ x 3)))                \ev  45%
\end{scheme}

An expanded \hyper{body} containing internal definitions can always be
converted into a completely equivalent {\cf letrec*} expression.  For
example, the {\cf let} expression in the above example is equivalent
to

\begin{scheme}
(let ((x 5))
  (letrec* ((foo (lambda (y) (bar x y)))
            (bar (lambda (a b) (+ (* a b) a))))
    (foo (+ x 3))))%
\end{scheme}

Just as for the equivalent {\cf letrec*} expression, it is an error if it is not
possible to evaluate each \hyper{expression} of every internal
definition in a \hyper{body} without assigning or referring to
the value of the corresponding \hyper{variable} or the \hyper{variable}
of any of the definitions that follow it in \hyper{body}.

It is an error to define the same identifier more than once in the
same \hyper{body}.

Wherever an internal definition may occur,
{\tt(begin \hyperi{definition} \dotsfoo)}
is equivalent to the sequence of definitions
that form the body of the \ide{begin}.

\subsection{Multiple-value definitions}

The construct {\cf define-values} introduces new definitions like
{\cf define}, but can create multiple definitions from a single
expression returning multiple values.
It is allowed wherever {\cf define} is allowed.

\begin{entry}{%
\proto{define-values}{ \hyper{formals} \hyper{expression}}{\exprtype}}\nobreak

It is an error if a variable appears more than once in the set of \hyper{formals}.

\semantics
\hyper{Expression} is evaluated, and the \hyper{formals} are bound
to the return values in the same way that the \hyper{formals} in a
{\cf lambda} expression are matched to the arguments in a procedure
call.

\begin{scheme}
(let ()
  (define-values (x y) (values 1 2))
  (+ x y))     \ev 3%
\end{scheme}

\end{entry}

\section{Syntax definitions}

Syntax definitions are valid wherever definitions are.
\mainindex{syntax definition}
They have the following form:\mainschindex{define-syntax}

{\tt(define-syntax \hyper{keyword} \hyper{transformer spec})}

\hyper{Keyword} is an identifier, and
the \hyper{transformer spec} should be an instance of \ide{syntax-rules}.
If the {\cf define-syntax} occurs at the top level, then the top-level
syntactic environment is extended by binding the
\hyper{keyword} to the specified transformer, but existing references
to any top-level binding for \hyper{keyword} remain unchanged.
Otherwise, it is an {\em internal syntax definition}, and is local to the
\hyper{body} in which it is defined.

\begin{scheme}
(let ((x 1) (y 2))
  (define-syntax swap!
    (syntax-rules ()
      ((swap! a b)
       (let ((tmp a))
         (set! a b)
         (set! b tmp)))))
  (swap! x y)
  (list x y))                \ev (2 1)%
\end{scheme}

\todo{Shinn: This description is hideous.
Cowan: But now less hideous than before.}

Macros can expand into definitions in any context that permits
them. However, it is an error for a definition to define an
identifier whose binding has to be known in order to determine the meaning of the
definition itself, or of any preceding definition that belongs to the
same group of internal definitions. Similarly, it is an error for an
internal definition to define an identifier whose binding has to be known
in order
to determine the boundary between the internal definitions and the
expressions of the body it belongs to. For example, the following are
errors:

\begin{scheme}
(define define 3)

(begin (define begin list))

(let-syntax
  ((foo (syntax-rules ()
          ((foo (proc args ...) body ...)
           (define proc
             (lambda (args ...)
               body ...))))))
  (let ((x 3))
    (foo (plus x y) (+ x y))
    (define foo x)
    (plus foo x)))
\end{scheme}

\todo{Shinn: Example using internal define-syntax.}

\section{Record type definitions}
\label{usertypes}

\defining{Record type definitions} are used to introduce new data types, called
\defining{record types}.
The values of a record type are called \defining{records} and are
aggregations of zero or more \defining{fields}, each of which holds a single location.
A predicate, a constructor, and field accessors and
mutators are defined for each record type.
Record type definitions are valid wherever definitions are.

\begin{entry}{%
\pproto{(define-record-type \hyper{name}}{syntax}
\hspace*{4em}{\tt \hyper{constructor} \hyper{pred} \hyper{field} \dotsfoo})}

\syntax
\hyper{name} and \hyper{pred} should be identifiers.
The \hyper{constructor} should be of the form
\begin{scheme}
(\hyper{constructor name} \hyper{field name} \dotsfoo)%
\end{scheme}
and each \hyper{field} should be either of the form
\begin{scheme}
(\hyper{field name} \hyper{accessor name})%
\end{scheme}
or of the form
\begin{scheme}
(\hyper{field name} \hyper{accessor name} \hyper{modifier name})%
\end{scheme}

It is an error for the same identifier to occur more than once as a
field name.

{\cf define-record-type} is generative: each use creates a new record
type that is distinct from all existing types, including Scheme's
predefined types and other record types --- even record types of
the same name or structure.

An instance of {\cf define-record-type} is equivalent to the following
definitions:

\begin{itemize}

\item \hyper{name} is bound to a representation of the record type
itself.  This may be a run-time object or a purely syntactic representation.

\item \hyper{constructor name} is bound to a procedure that takes as
  many arguments as there are \hyper{field name}s in the
  \texttt{(\hyper{constructor name} \dotsfoo)} subform and returns a
  new record of type \hyper{name}.  Fields whose names are listed with
  \hyper{constructor name} have the corresponding argument as their
  initial value.  The initial values of all other fields are
  unspecified.

\item \hyper{pred} is bound to a predicate that returns \schtrue{} when given a
  value returned by the procedure bound to  \hyper{constructor name} and \schfalse{} for
  everything else.

\item Each \hyper{accessor name} is bound to a procedure that takes a record of
  type \hyper{name} and returns the current value of the corresponding
  field.  It is an error to pass an accessor a value which is not a
  record of the appropriate type.

\item Each \hyper{modifier name} is bound to a procedure that takes a record of
  type \hyper{name} and a value which becomes the new value of the
  corresponding field; an unspecified value is returned.  It is an
  error to pass a modifier a first argument which is not a record of
  the appropriate type.

\end{itemize}

For instance, the following definition

\begin{scheme}
(define-record-type <pare>
  (kons x y)
  pare?
  (x kar set-kar!)
  (y kdr))
\end{scheme}

defines {\cf kons} to be a constructor, {\cf kar} and {\cf kdr}
to be accessors, {\cf set-kar!} to be a modifier, and {\cf pare?}
to be a predicate for instances of {\cf <pare>}.

\begin{scheme}
  (pare? (kons 1 2))        \ev \schtrue
  (pare? (cons 1 2))        \ev \schfalse
  (kar (kons 1 2))          \ev 1
  (kdr (kons 1 2))          \ev 2
  (let ((k (kons 1 2)))
    (set-kar! k 3)
    (kar k))                \ev 3
\end{scheme}

\end{entry}


\section{Libraries}
\label{libraries}

Libraries provide a way to organize Scheme programs into reusable parts
with explicitly defined interfaces to the rest of the program.  This
section defines the notation and semantics for libraries.


\subsection{Library Syntax}

A library definition takes the following form:

\begin{scheme}
(define-library \hyper{library name}
  \hyper{library declaration} \dotsfoo)
\end{scheme}

\hyper{library name} is a list whose members are identifiers or unsigned exact integers that is used to
identify the library uniquely when importing from other programs or
libraries.
Libraries whose first identifier is {\cf scheme} are reserved for use by this
report and future versions of this report.
Libraries whose first identifier is {\cf srfi} are reserved for libraries
implementing Scheme Requests for Implementation.

A \hyper{library declaration} may be any of:

\begin{itemize}

\item{\tt(export \hyper{export spec} \dotsfoo)}

\item{\tt(import \hyper{import set} \dotsfoo)}

\item{\tt(begin \hyper{command or definition} \dotsfoo)}

\item{\tt(include \hyperi{$filename$} \hyperii{$filename$} \dotsfoo)}

\item{\tt(include-ci \hyperi{$filename$} \hyperii{$filename$} \dotsfoo)}

\item{\tt(cond-expand \hyper{cond-expand clause} \dotsfoo)}

\end{itemize}

An \ide{export} declaration specifies a list of identifiers which
can be made visible to other libraries or programs.  An
An \hyper{export spec} takes one of the following forms:

\begin{itemize}
\item{\hyper{identifier}}
\item{\tt{(rename \hyperi{$identifier$} \hyperii{$identifier$})}}
\end{itemize}

In an \hyper{export spec}, an \hyper{identifier} names a single
binding defined within or imported into the library, where the
external name for the export is the same as the name of the binding
within the library. A rename spec exports the binding 
defined within or imported into the library and named by
\hyperi{$identifier$} in each
{\tt(\hyperi{$identifier$} \hyperii{$identifier$})} pairing,
using \hyperii{$identifier$} as the external name.

An \ide{import} declaration provides a way to import the identifiers
exported by a library.  Each \hyper{import set} names a set of bindings
from another library and possibly specifies local names for the
imported bindings. It takes one of the following forms:

\begin{itemize}
\item {\tt\hyper{library name}}
\item {\tt(only \hyper{import set} \hyper{identifier} \dotsfoo)}
\item {\tt(except \hyper{import set} \hyper{identifier} \dotsfoo)}
\item {\tt(prefix \hyper{import set} \hyper{identifier})}
\item {\tt(rename \hyperi{import set} (\hyperii{$identifier$} \hyper{$identifier$}) \dotsfoo)}
\end{itemize}

In the first form, all of the identifiers in the named library's export
clauses are imported with the same names (or the exported names if
exported with \ide{rename}).  The additional \hyper{import set}
forms modify this set as follows:

\begin{itemize}

\item \ide{only} produces a subset of the given
  \hyper{import set}, including only the listed identifiers (after any
  renaming).  It is an error if any of the listed identifiers are
  not found in the original set.

\item \ide{except} produces a subset of the given
  \hyper{import set}, excluding the listed identifiers (after any
  renaming). It is an error if any of the listed identifiers are not
  found in the original set.

\item \ide{rename} modifies the given \hyper{import set},
  replacing each instance of \hyperi{$identifier$} with
  \hyperii{$identifier$}. It is an error if any of the listed
  identifiers are not found in the original set.

\item \ide{prefix} automatically renames all identifiers in
  the given \hyper{import set}, prefixing each with the specified
  \hyper{identifier}.

\end{itemize}

\ide{Import} declarations may also be made at the top level of a
program.  In a library declaration, it is an error to import the same
identifier more than once with different bindings, or to redefine or
mutate an imported binding with {\cf define}, {\cf define-syntax}
or {\cf set!}.  However, a REPL should permit these actions.

The \ide{begin}, \ide{include}, and \ide{include-ci} declarations are
used to specify the commands and definitions that make up the body of
the library.  \ide{Begin} takes a list of expressions and definitions to be spliced
literally, analogous to the top-level \ide{begin}.  
\ide{Include} and
\ide{include-ci} both take one or more filenames expressed as string literals,
apply an implementation-specific algorithm to find corresponding files,
read the whole contents of each file,
and include the results into the library body or program as
though wrapped in a top-level \ide{begin}.
The difference between the two is that \ide{include-ci} reads each file
as if it began with the {\cf{}\#!fold-case} directive, while \ide{include}
does not.
All three may appear at the top level of a program.

\begin{note}
Implementations are encouraged to search for files in the directory
which contains the including file, and to provide a way for users to
specify other directories to search.
\end{note}

\begin{note}
For portability, \ide{include} and \ide{include-ci} must operate on source files.
Their operation on other kinds of files necessarily varies among
implementations.
\end{note}

The \ide{cond-expand} library declaration
provides a way to statically
expand different library declarations depending on the 
implementation under which the library is being loaded.  A
\hyper{cond-expand clause} takes the following form:

{\tt(\hyper{feature requirement} \hyper{library declaration} \dotsfoo)}

The last clause may be an ``else clause,'' which has the form

{\tt(else \hyper{library declaration} \dotsfoo)}

A \hyper{feature requirement} takes one of the following forms:

\begin{itemize}
\item {\tt\hyper{feature identifier}}
\item {\tt(library \hyper{library name})}
\item {\tt(and \hyper{feature requirement} \dotsfoo)}
\item {\tt(or \hyper{feature requirement} \dotsfoo)}
\item {\tt(not \hyper{feature requirement})}
\end{itemize}

Each implementation maintains a list of feature identifiers which are
present, as well as a list of libraries which can be imported.  The
value of a \hyper{feature requirement} is determined by replacing
each \hyper{feature identifier} and {\tt(library \hyper{library name})}
on the implementation's lists with \schtrue, and all other feature
identifiers and library names with \schfalse, then evaluating the
resulting expression as a Scheme boolean expression under the normal
interpretation of {\cf and}, {\cf or}, and {\cf not}.

A \ide{cond-expand} is then expanded by evaluating the
\hyper{feature requirement}s of successive \hyper{cond-expand clause}s
in order, until one of them returns \schtrue.  When a true clause is
found, the corresponding \hyper{library declaration}s are spliced into
the current library definition and the remaining clauses are ignored.
If none of the \hyper{feature requirement}s evaluate to \schtrue, then
if there is an \ide{else} clause, its \hyper{library declaration}s are
included.  Otherwise, the \ide{cond-expand} has no effect.

The exact features provided are implementation-defined, but for
portability a core set of features is given in
appendix~\ref{stdfeatures}.

\todo{Shinn: Perhaps make this a separate subsection describing a
  library ``resolution'' phase which runs prior to library expansion.}

After all \ide{cond-expand} library declarations are expanded, a new environment is
constructed for the library consisting of all imported bindings.  The
expressions and declarations from all \ide{begin}, \ide{include} and \ide{include-ci}
declarations are expanded in that environment in the order in which
they occur in the library declaration.

The top-level expressions in a library are executed in the order in which
they occur when the library is loaded.  A library is loaded zero or more
times when it is imported by a program or by another library which is
about to be loaded, but must be loaded at least once per program in
which it is so imported.

\todo{Shinn: Mention it may also be loaded (or not in some cases, if
  the compiler is clever) during batch compilation?}

\subsection{Library example}
The following example shows
how a program may be divided into libraries plus a relatively small
main program.
If the main program is entered into a REPL, it is not necessary to import
the base module.

\begin{scheme}

(define-library (stack)
  (export make push! pop! empty!)
  (import (scheme base))
  (begin
   (define (make) (list '()))
   (define (push! s v)
     (set-car! s (cons v (car s))))
   (define (pop! s) (let ((v (caar s)))
                      (set-car! s (cdar s))
                      v))
   (define (empty! s) (set-car! s '()))))

(define-library (balloons)
  (export make push pop)
  (import (scheme base))
  (begin
   (define (make w h) (cons w h))
   (define (push b amt)
     (cons (- (car b) amt) (+ (cdr b) amt)))
   (define (pop b) (display "Boom! ") 
                   (display (* (car b) (cdr b))) 
                   (newline))))

(define-library (party)
  ;; Total exports:
  ;; make, push, push!, make-party, pop!
  (export (rename (balloon:make make)
                  (balloon:push push))
          push!
          make-party
          (rename (party-pop! pop!)))
  (import
   (scheme base)
   (only (stack) make push! pop!) ; not empty!
   (prefix (balloons) balloon:))
  (begin
   ;; Creates a party as a stack of balloons,
   ;; starting with two balloons
   (define (make-party)
     (let ((s (make))) ; from stack
       (push! s (balloon:make 10 10))
       (push! s (balloon:make 12 9))
       s))
   (define (party-pop! p)
     (balloon:pop (pop! p)))))

;; The main program.
(import (scheme base) (party))
(define p (make-party))
(pop! p)        ; displays "Boom! 108"
(push! p (push (make 5 5) 1))
(pop! p)       ; displays "Boom! 24"

\end{scheme}
