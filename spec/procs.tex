% Initial environment

%\vfill\eject
\chapter{Standard procedures}
\label{initialenv}
\label{builtinchapter}

\mainindex{initial environment}
\mainindex{top level environment}
\mainindex{procedure}

\todo{Shinn: #112 repl definitions and #159 base environments}

This chapter describes Scheme's built-in procedures.  The initial (or
``top level'') Scheme environment starts out with a number of variables
bound to locations containing useful values, most of which are primitive
procedures that manipulate data.  For example, the variable {\cf abs} is
bound to (a location initially containing) a procedure of one argument
that computes the absolute value of a number, and the variable {\cf +}
is bound to a procedure that computes sums.  

A program may use a top-level definition to bind any variable.  It may
subsequently alter any such binding by an assignment (see \ref{assignment}).
These operations do not modify the behavior of Scheme's built-in
procedures.  Altering any top-level binding that has not been introduced by a
definition has an unspecified effect on the behavior of the built-in procedures.

\section{Equivalence predicates}
\label{equivalencesection}

A \defining{predicate} is a procedure that always returns a boolean
value (\schtrue{} or \schfalse).  An \defining{equivalence predicate} is
the computational analogue of a mathematical equivalence relation (it is
symmetric, reflexive, and transitive).  Of the equivalence predicates
described in this section, {\cf eq?}\ is the finest or most
discriminating, and {\cf equal?}\ is the coarsest.  {\cf Eqv?}\ is
slightly less discriminating than {\cf eq?}.  \todo{Pitman doesn't like
this paragraph.  Lift the discussion from the Maclisp manual.  Explain
why there's more than one predicate.}


\begin{entry}{%
\proto{eqv?}{ \vari{obj} \varii{obj}}{procedure}}

The {\cf eqv?} procedure defines a useful equivalence relation on objects.
Briefly, it returns \schtrue{} if \vari{obj} and \varii{obj} should
normally be regarded as the same object.  This relation is left slightly
open to interpretation, but the following partial specification of
{\cf eqv?} holds for all implementations of Scheme.

The {\cf eqv?} procedure returns \schtrue{} if:

\begin{itemize}
\item \vari{obj} and \varii{obj} are both \schtrue{} or both \schfalse.

\item \vari{obj} and \varii{obj} are both symbols and

\begin{scheme}
(string=? (symbol->string obj1)
          (symbol->string obj2))
    \ev  \schtrue%
\end{scheme}

\begin{note} 
This assumes that neither \vari{obj} nor \varii{obj} is an ``uninterned
symbol'' as alluded to in section~\ref{symbolsection}.  This report does
not presume to specify the behavior of {\cf eqv?} on implementation-dependent
extensions.
\end{note}

\item \vari{obj} and \varii{obj} are both numbers, are numerically
equal (see {\cf =}, section~\ref{numbersection}), and are either both
exact\index{exact} or both inexact\index{inexact}.

\item \vari{obj} and \varii{obj} are both characters and are the same
character according to the {\cf char=?} procedure
(section~\ref{charactersection}).

\item both \vari{obj} and \varii{obj} are the empty list.

\item \vari{obj} and \varii{obj} are pairs, vectors, bytevectors, records,
or strings that denote the same locations in the store
(section~\ref{storagemodel}).
\end{itemize}

The {\cf eqv?} procedure returns \schfalse{} if:

\begin{itemize}
\item \vari{obj} and \varii{obj} are of different types
(section~\ref{disjointness}).

\item one of \vari{obj} and \varii{obj} is \schtrue{} but the other is
\schfalse{}.

\item \vari{obj} and \varii{obj} are symbols but

\begin{scheme}
(string=? (symbol->string \vari{obj})
          (symbol->string \varii{obj}))
    \ev  \schfalse%
\end{scheme}

\item one of \vari{obj} and \varii{obj} is an exact number but the other
is an inexact number.

\item \vari{obj} and \varii{obj} are numbers for which the {\cf =}
procedure returns \schfalse{}.

\item \vari{obj} and \varii{obj} are characters for which the {\cf char=?}
procedure returns \schfalse{}.

\item one of \vari{obj} and \varii{obj} is the empty list but the other
is not.

\item \vari{obj} and \varii{obj} are pairs, vectors, bytevectors, records,
or strings that denote distinct locations.

\item \vari{obj} and \varii{obj} are procedures that would behave differently
(return different value(s) or have different side effects) for some arguments.

\end{itemize}

\begin{scheme}
(eqv? 'a 'a)                     \ev  \schtrue
(eqv? 'a 'b)                     \ev  \schfalse
(eqv? 2 2)                       \ev  \schtrue
(eqv? '() '())                   \ev  \schtrue
(eqv? 100000000 100000000)       \ev  \schtrue
(eqv? (cons 1 2) (cons 1 2))     \ev  \schfalse
(eqv? (lambda () 1)
      (lambda () 2))             \ev  \schfalse
(eqv? \#f 'nil)                  \ev  \schfalse
\end{scheme}

The following examples illustrate cases in which the above rules do
not fully specify the behavior of {\cf eqv?}.  All that can be said
about such cases is that the value returned by {\cf eqv?} must be a
boolean.

\begin{scheme}
(eqv? "" "")             \ev  \unspecified
(eqv? '\#() '\#())         \ev  \unspecified
(eqv? (lambda (x) x)
      (lambda (x) x))    \ev  \unspecified
(let ((p (lambda (x) x)))
  (eqv? p p))                    \ev  \unspecified
(eqv? (lambda (x) x)
      (lambda (y) y))    \ev  \unspecified%
\end{scheme}

The next set of examples shows the use of {\cf eqv?}\ with procedures
that have local state.  {\cf Gen-counter} must return a distinct
procedure every time, since each procedure has its own internal counter.
{\cf Gen-loser}, however, returns equivalent procedures each time, since
the local state does not affect the value or side effects of the
procedures.  However, {\cf eqv?} may or may not detect this equivalence.

\begin{scheme}
(define gen-counter
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) n))))
(let ((g (gen-counter)))
  (eqv? g g))           \ev  \schtrue
(eqv? (gen-counter) (gen-counter))
                        \ev  \schfalse
(define gen-loser
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) 27))))
(let ((g (gen-loser)))
  (eqv? g g))           \ev  \schtrue
(eqv? (gen-loser) (gen-loser))
                        \ev  \unspecified

(letrec ((f (lambda () (if (eqv? f g) 'both 'f)))
         (g (lambda () (if (eqv? f g) 'both 'g))))
  (eqv? f g))
                        \ev  \unspecified

(letrec ((f (lambda () (if (eqv? f g) 'f 'both)))
         (g (lambda () (if (eqv? f g) 'g 'both))))
  (eqv? f g))
                        \ev  \schfalse%
\end{scheme}

% Objects of distinct types must never be regarded as the same object,
% except that \schfalse{} and the empty list\index{empty list} are permitted to
% be identical.
%
% \begin{scheme}
% (eqv? '() \schfalse)    \ev  \unspecified%
% \end{scheme}

Since it is an error to modify constant objects (those returned by
literal expressions), implementations are permitted, though not
required, to share structure between constants where appropriate.  Thus
the value of {\cf eqv?} on constants is sometimes
implementation-dependent.

\begin{scheme}
(eqv? '(a) '(a))                 \ev  \unspecified
(eqv? "a" "a")                   \ev  \unspecified
(eqv? '(b) (cdr '(a b)))	 \ev  \unspecified
(let ((x '(a)))
  (eqv? x x))                    \ev  \schtrue%
\end{scheme}

\begin{rationale} 
The above definition of {\cf eqv?} allows implementations latitude in
their treatment of procedures and literals:  implementations are free
either to detect or to fail to detect that two procedures or two literals
are equivalent to each other, and can decide whether or not to
merge representations of equivalent objects by using the same pointer or
bit pattern to represent both.
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{eq?}{ \vari{obj} \varii{obj}}{procedure}}

{\cf Eq?}\ is similar to {\cf eqv?}\ except that in some cases it is
capable of discerning distinctions finer than those detectable by
{\cf eqv?}.

\vest {\cf Eq?}\ and {\cf eqv?}\ are guaranteed to have the same
behavior on symbols, booleans, the empty list, pairs, procedures,
and non-empty
strings and vectors.  {\cf Eq?}'s behavior on numbers and characters is
implementation-dependent, but it will always return either true or
false, and will return true only when {\cf eqv?}\ would also return
true.  {\cf Eq?} may also behave differently from {\cf eqv?} on empty
vectors and empty strings.

\begin{scheme}
(eq? 'a 'a)                     \ev  \schtrue
(eq? '(a) '(a))                 \ev  \unspecified
(eq? (list 'a) (list 'a))       \ev  \schfalse
(eq? "a" "a")                   \ev  \unspecified
(eq? "" "")                     \ev  \unspecified
(eq? '() '())                   \ev  \schtrue
(eq? 2 2)                       \ev  \unspecified
(eq? \#\backwhack{}A \#\backwhack{}A) \ev  \unspecified
(eq? car car)                   \ev  \schtrue
(let ((n (+ 2 3)))
  (eq? n n))      \ev  \unspecified
(let ((x '(a)))
  (eq? x x))      \ev  \schtrue
(let ((x '\#()))
  (eq? x x))      \ev  \schtrue
(let ((p (lambda (x) x)))
  (eq? p p))      \ev  \schtrue%
\end{scheme}

\todo{Needs to be explained better above.  How can this be made to be
not confusing?  A table maybe?}

\begin{rationale} It will usually be possible to implement {\cf eq?}\ much
more efficiently than {\cf eqv?}, for example, as a simple pointer
comparison instead of as some more complicated operation.  One reason is
that it may not be possible to compute {\cf eqv?}\ of two numbers in
constant time, whereas {\cf eq?}\ implemented as pointer comparison will
always finish in constant time.  {\cf Eq?}\ may be used like {\cf eqv?}\
in applications using procedures to implement objects with state since
it obeys the same constraints as {\cf eqv?}.
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{equal?}{ \vari{obj} \varii{obj}}{procedure}}

{\cf Equal?} recursively compares the contents of pairs, vectors, and
strings, applying {\cf eqv?} on other objects such as numbers and symbols.
A rule of thumb is that objects are generally {\cf equal?} if they print
the same.  {\cf Equal?}\ must always terminate, even if its arguments are
circular data structures.

\begin{scheme}
(equal? 'a 'a)                  \ev  \schtrue
(equal? '(a) '(a))              \ev  \schtrue
(equal? '(a (b) c)
        '(a (b) c))             \ev  \schtrue
(equal? "abc" "abc")            \ev  \schtrue
(equal? 2 2)                    \ev  \schtrue
(equal? (make-vector 5 'a)
        (make-vector 5 'a))     \ev  \schtrue
(equal? (lambda (x) x)
        (lambda (y) y))  \ev  \unspecified%
\end{scheme}


\end{entry}


\section{Numbers}
\label{numbersection}
\index{number}

%%R4%% The excessive use of the code font in this section was
% confusing, somewhat obnoxious, and inconsistent with the rest
% of the report and with parts of the section itself.  I added
% a \tupe no-op, and changed most old uses of \type to \tupe,
% to make it easier to change the fonts back if people object
% to the change.

\newcommand{\type}[1]{{\it#1}}
\newcommand{\tupe}[1]{{#1}}

%% This paragraph is stale.
%% Numerical computation has traditionally been neglected by the Lisp
%% community.  Until Common Lisp there was no carefully thought out
%% strategy for organizing numerical computation, and with the exception of
%% the MacLisp system \cite{Pitman83} little effort was made to
%% execute numerical code efficiently.  This report recognizes the excellent work
%% of the Common Lisp committee and accepts many of their recommendations.
%% In some ways this report simplifies and generalizes their proposals in a manner
%% consistent with the purposes of Scheme.

It is important to distinguish between mathematical numbers, the
Scheme numbers that attempt to model them, the machine representations
used to implement the Scheme numbers, and notations used to write numbers.
This report uses the types \type{number}, \type{complex}, \type{real},
\type{rational}, and \type{integer} to refer to both mathematical numbers
and Scheme numbers.  Machine representations such as fixed point and
floating point are referred to by names such as \type{fixnum} and
\type{flonum}.
Fixnums are integers with a limited and machine-dependent range;
flonums are real numbers with a limited and machine-dependent
range and precision.

%%R4%% I did some reorganizing here to move the discussion of mathematical
% numbers before the discussion of the Scheme numbers, hoping that this
% would help to motivate the discussion of representation independence.

\subsection{Numerical types}
\label{numericaltypes}
\index{numerical types}

%%R4%% A Scheme system provides data of type \type{number}, which is the most
%general numerical type supported by that system.
%\type{Number} is
%likely to be a complicated union type implemented in terms of
%\type{fixnum}s, \type{bignum}s, \type{flonum}s, and so forth, but this
%should not be apparent to a naive user.  What the user should see is
%that the usual operations on numbers produce the mathematically
%expected results, within the limits of the implementation.

%%R4%%  I rewrote the following paragraph to make the various levels of
% the tower into subsets of each other, instead of relating them by
% injections.  I think the injections tended to put people in the frame
% of mind of thinking about coercions between non-overlapping numeric
% types in mainstream programming languages.

\vest Mathematically, numbers may be arranged into a tower of subtypes
%%R4%% with injections relating adjacent levels of the tower:
in which each level is a subset of the level above it:
\begin{tabbing}
\ \ \ \ \ \ \ \ \ \=\tupe{number} \\
\> \tupe{complex} \\
\> \tupe{real} \\
\> \tupe{rational} \\
\> \tupe{integer} 
\end{tabbing}

For example, 3 is an integer.  Therefore 3 is also a rational,
a real, and a complex.  The same is true of the Scheme numbers
that model 3.  For Scheme numbers, these types are defined by the
predicates \ide{number?}, \ide{complex?}, \ide{real?}, \ide{rational?},
and \ide{integer?}.

There is no simple relationship between a number's type and its
representation inside a computer.  Although most implementations of
Scheme will offer at least two different representations of 3, these
different representations denote the same integer.

%%R4%% I moved "Implementations of Scheme are not required to implement
% the whole tower..." to the subsection on implementation restrictions.

Scheme's numerical operations treat numbers as abstract data, as
independent of their representation as possible.  Although an implementation
of Scheme may use fixnum, flonum, and perhaps other representations for
numbers, this should not be apparent to a casual programmer writing
simple programs.

It is necessary, however, to distinguish between numbers that are
represented exactly and those that may not be.  For example, indexes
into data structures must be known exactly, as must some polynomial
coefficients in a symbolic algebra system.  On the other hand, the
results of measurements are inherently inexact, and irrational numbers
may be approximated by rational and therefore inexact approximations.
In order to catch uses of inexact numbers where exact numbers are
required, Scheme explicitly distinguishes exact from inexact numbers.
This distinction is orthogonal to the dimension of type.

\subsection{Exactness}

%%R4%% I tried to direct the following paragraph away from philosophizing
% about the exactness of mathematical numbers, and toward philosophizing
% about the exactness of Scheme numbers.

\mainindex{exactness} \label{exactly}
Scheme numbers are either \type{exact} or \type{inexact}.  A number is
\tupe{exact} if it was written as an exact constant or was derived from
\tupe{exact} numbers using only \tupe{exact} operations.  A number is
\tupe{inexact} if it was written as an inexact constant,
%%R4%% models a quantity (e.g., a measurement) known only approximately,
if it was
derived using \tupe{inexact} ingredients, or if it was derived using
\tupe{inexact} operations. Thus \tupe{inexact}ness is a contagious
property of a number.
%%R4%% The rest of this paragraph (from R3RS) has been dropped.

\vest If two implementations produce \tupe{exact} results for a
computation that did not involve \tupe{inexact} intermediate results,
the two ultimate results will be mathematically equivalent.  This is
generally not true of computations involving \tupe{inexact} numbers
since approximate methods such as floating point arithmetic may be used,
but it is the duty of each implementation to make the result as close as
practical to the mathematically ideal result.

\vest Rational operations such as {\cf +} should always produce
\tupe{exact} results when given \tupe{exact} arguments.
%%R4%%If an implementation is
%unable to represent an \tupe{exact} result (for example, if it does not
%support infinite precision integers and rationals)
If the operation is unable to produce an \tupe{exact} result,
then it may either report the violation of an implementation restriction
or it may silently coerce its
result to an \tupe{inexact} value.
%%R4%%Such a coercion may cause an error later.
See section~\ref{restrictions}.

\vest With the exception of \ide{inexact->exact}, the operations described in
this section must generally return inexact results when given any inexact
arguments.  An operation may, however, return an \tupe{exact} result if it can
prove that the value of the result is unaffected by the inexactness of its
arguments.  For example, multiplication of any number by an \tupe{exact} zero
may produce an \tupe{exact} zero result, even if the other argument is
\tupe{inexact}.

\subsection{Implementation restrictions}

\index{implementation restriction}\label{restrictions}

\vest Implementations of Scheme are not required to implement the whole
tower of subtypes given in section~\ref{numericaltypes},
but they must implement a coherent subset consistent with both the
purposes of the implementation and the spirit of the Scheme language.
For example, an implementation in which all numbers are \tupe{real}
may still be quite useful.

\vest Implementations may also support only a limited range of numbers of
any type, subject to the requirements of this section.  The supported
range for \tupe{exact} numbers of any type may be different from the
supported range for \tupe{inexact} numbers of that type.  For example,
an implementation that uses flonums to represent all its
\tupe{inexact} \tupe{real} numbers may
support a practically unbounded range of \tupe{exact} \tupe{integer}s
and \tupe{rational}s
while limiting the range of \tupe{inexact} \tupe{real}s (and therefore
the range of \tupe{inexact} \tupe{integer}s and \tupe{rational}s)
to the dynamic range of the flonum format.
Furthermore
the gaps between the representable \tupe{inexact} \tupe{integer}s and
\tupe{rational}s are
likely to be very large in such an implementation as the limits of this
range are approached.

\vest An implementation of Scheme must support exact integers
throughout the range of numbers that may be used for indexes of
lists, vectors, and strings or that may result from computing the length of a
list, vector, or string.  The \ide{length}, \ide{vector-length},
and \ide{string-length} procedures must return an exact
integer, and it is an error to use anything but an exact integer as an
index.  Furthermore any integer constant within the index range, if
expressed by an exact integer syntax, will indeed be read as an exact
integer, regardless of any implementation restrictions that may apply
outside this range.  Finally, the procedures listed below will always
return an exact integer result provided all their arguments are exact integers
and the mathematically expected result is representable as an exact integer
within the implementation:

\begin{scheme}
+            -             *
quotient     remainder     modulo
max          min           abs
numerator    denominator   gcd
lcm          floor         ceiling
truncate     round         rationalize
expt%
\end{scheme}

\vest Implementations are encouraged, but not required, to support
\tupe{exact} \tupe{integer}s and \tupe{exact} \tupe{rational}s of
practically unlimited size and precision, and to implement the
above procedures and the {\cf /} procedure in
such a way that they always return \tupe{exact} results when given \tupe{exact}
arguments.  If one of these procedures is unable to deliver an \tupe{exact}
result when given \tupe{exact} arguments, then it may either report a
violation of an
implementation restriction or it may silently coerce its result to an
\tupe{inexact} number.  Such a coercion may cause an error later.

%%R4%% I moved this stuff here.
% It seems to me that the only thing that this requires is that
% implementations that support inexact numbers have to have both
% exact and inexact representations for the integers 0 through 15.
% If that's what it's saying, I'd rather say it that way.
% On the other hand, letting the limit be as small as 15 sounds a
% tad silly, though I think I understand how that number was arrived at.
% (Or is 35 the number?)
%
%Implementations are encouraged, but not required, to support \tupe{inexact}
%numbers.  For any implementation that supports \tupe{inexact} numbers,
%there is a subset of the integers for which there are both \tupe{exact} and
%\tupe{inexact} representations.  This subset must include all non-negative
%integers up to some limit specified by the implementation.  This limit
%must be 16 or greater.  The
%\ide{exact\coerce{}inexact} and \ide{inexact\coerce{}exact}
%procedures implement the natural one-to-one correspondence between
%the \tupe{inexact} and \tupe{exact} integers within this range.

\vest An implementation may use floating point and other approximate 
representation strategies for \tupe{inexact} numbers.
%%R4%% The following sentence seemed a bit condescending as well as
% awkward.  It didn't seem to be very enforceable, so I flushed it.
%
%This is not to
%say that implementors need not use the best known algorithms for
%\tupe{inexact} computations---only that approximate methods of high
%quality are allowed.
%
This report recommends, but does not require, that the IEEE 754
standard be followed by implementations that use
flonum representations, and that implementations using
other representations should match or exceed the precision achievable
using these floating point standards~\cite{IEEE}.

\vest In particular, implementations that use flonum representations
must follow these rules: A \tupe{flonum} result
must be represented with at least as much precision as is used to express any of
the inexact arguments to that operation.  It is desirable (but not required) for
potentially inexact operations such as {\cf sqrt}, when applied to \tupe{exact}
arguments, to produce \tupe{exact} answers whenever possible (for example the
square root of an \tupe{exact} 4 should be an \tupe{exact} 2).
If, however, an
\tupe{exact} number is operated upon so as to produce an \tupe{inexact} result
(as by {\cf sqrt}), and if the result is represented as a \tupe{flonum}, then
the most precise \tupe{flonum} format available must be used; but if the result
is represented in some other way then the representation must have at least as
much precision as the most precise \tupe{flonum} format available.

In addition, implementations that use flonum representations may
distinguish special number objects called \tupe{positive infinity},
\tupe{negative infinity}, and \tupe{NaN}.

Positive infinity is regarded as an inexact real (but not rational)
number object that represents an indeterminate number greater than the
numbers represented by all rational number objects. Negative infinity
is regarded as an inexact real (but not rational) number object that
represents an indeterminate number less than the numbers represented
by all rational numbers.

A NaN is regarded as an inexact real (but not rational) number object
so indeterminate that it might represent any real number, including
positive or negative infinity, and might even be greater than positive
infinity or less than negative infinity.
It might even represent no number at all, as in the case of 
{\cf (asin 2.0)}.

%Note that either the real or the imaginary part of a complex number
%can be an infinity or NaN.

Although Scheme allows a variety of written
%%R4%% representations of 
notations for
numbers, any particular implementation may support only some of them.
%%R4%%
For example, an implementation in which all numbers are \tupe{real}
need not support the rectangular and polar notations for complex
numbers.  If an implementation encounters an \tupe{exact} numerical constant that
it cannot represent as an \tupe{exact} number, then it may either report a
violation of an implementation restriction or it may silently represent the
constant by an \tupe{inexact} number.


\subsection{Syntax of numerical constants}
\label{numbernotations}

%@@@@LOSE@@@@

%%R4%%  I removed the following paragraph in an attempt to tighten up
% this subsection.  Except for its first sentence, which I moved to
% the subsection on implementation restrictions, I think its content
% is implied by the rest of the section.
%
%Although Scheme allows a variety of written representations of numbers,
%any particular implementation may support only some of them.
%These syntaxes are intended to be purely notational; any kind of number
%may be written in any form that the user deems convenient.  Of course,
%writing 1/7 as a limited-precision decimal fraction will not express the
%number exactly, but this approximate form of expression may be just what
%the user wants to see.

The syntax of the written representations for numbers is described formally in
section~\ref{numbersyntax}.  Note that case is not significant in numerical
constants.

%%R4%%  See section~\ref{numberformats} for many examples.

A number may be written in binary, octal, decimal, or
hexadecimal by the use of a radix prefix.  The radix prefixes are {\cf
\#b}\sharpindex{b} (binary), {\cf \#o}\sharpindex{o} (octal), {\cf
\#d}\sharpindex{d} (decimal), and {\cf \#x}\sharpindex{x} (hexadecimal).  With
no radix prefix, a number is assumed to be expressed in decimal.

A
%%R4%%
% simple
numerical constant may be specified to be either \tupe{exact} or
\tupe{inexact} by a prefix.  The prefixes are {\cf \#e}\sharpindex{e}
for \tupe{exact}, and {\cf \#i}\sharpindex{i} for \tupe{inexact}.  An exactness
prefix may appear before or after any radix prefix that is used.  If
the written representation of a number has no exactness prefix, the
constant may be either \tupe{inexact} or \tupe{exact}.  It is
\tupe{inexact} if it contains a decimal point, an
exponent, or a ``\sharpsign'' character in the place of a digit,
otherwise it is \tupe{exact}.
%%R4%%  With our new syntax, the following sentence is redundant:
%
%The written representation of a
%compound number, such as a ratio or a complex, is exact if and only if
%all of its constituents are exact.

In systems with \tupe{inexact} numbers
of varying precisions it may be useful to specify
the precision of a constant.  For this purpose,
implementations may accept numerical constants
written with an exponent marker that indicates the
desired precision of the \tupe{inexact}
representation.  The letters {\cf s}, {\cf f},
{\cf d}, and {\cf l}, meaning \var{short}, \var{single},
\var{double}, and \var{long} precision respectively,
are acceptable in place of {\cf e}.
The default precision has at least as much precision
as \var{double}, but
implementations may wish to allow this default to be set by the user.

\begin{scheme}
3.14159265358979F0
       {\rm Round to single ---} 3.141593
0.6L0
       {\rm Extend to long ---} .600000000000000%
\end{scheme}

The numbers positive infinity, negative infinity and NaN are written
{\cf +inf.0}, {\cf -inf.0} and {\cf +nan.0} respectively.

\subsection{Numerical operations}

The reader is referred to section~\ref{typeconventions} for a summary
of the naming conventions used to specify restrictions on the types of
arguments to numerical routines.
%%R4%% The following sentence has already been said twice, and the
% term "exactness-preserving" is no longer defined by the Report.
%
%  Remember that
%an exactness-preserving operation may coerce its result to inexact if the
%implementation is unable to represent it exactly.
The examples used in this section assume that any numerical constant written
using an \tupe{exact} notation is indeed represented as an \tupe{exact}
number.  Some examples also assume that certain numerical constants written
using an \tupe{inexact} notation can be represented without loss of
accuracy; the \tupe{inexact} constants were chosen so that this is
likely to be true in implementations that use flonums to represent
inexact numbers.

\todo{Scheme provides the usual set of operations for manipulating
numbers, etc.}

\begin{entry}{%
\proto{number?}{ obj}{procedure}
\proto{complex?}{ obj}{procedure}
\proto{real?}{ obj}{procedure}
\proto{rational?}{ obj}{procedure}
\proto{integer?}{ obj}{procedure}}

These numerical type predicates can be applied to any kind of
argument, including non-numbers.  They return \schtrue{} if the object is
of the named type, and otherwise they return \schfalse{}.
In general, if a type predicate is true of a number then all higher
type predicates are also true of that number.  Consequently, if a type
predicate is false of a number, then all lower type predicates are
also false of that number.
%%R4%% The new section on implementation restrictions subsumes: 
% Not every system
%supports all of these types; for example, it is entirely possible to have a
%Scheme system that has only \tupe{integer}s.  Nonetheless every implementation
%of Scheme must have all of these predicates.

If \vr{z} is a complex number, then {\cf (real? \vr{z})} is true if
and only if {\cf (zero? (imag-part z))} and {\cf (exact? (imag-part
z))} are both true.  If \vr{x} is an inexact real number, then {\cf
(integer? \vr{x})} is true if and only if {\cf (= \vr{x} (round \vr{x}))}.

\begin{scheme}
(complex? 3+4i)         \ev  \schtrue
(complex? 3)            \ev  \schtrue
(real? 3)               \ev  \schtrue
(real? -2.5+0.0i)       \ev  \schtrue
(real? \#e1e10)          \ev  \schtrue
(rational? 6/10)        \ev  \schtrue
(rational? 6/3)         \ev  \schtrue
(integer? 3+0i)         \ev  \schtrue
(integer? 3.0)          \ev  \schtrue
(integer? 8/4)          \ev  \schtrue%
\end{scheme}

\begin{note}
The behavior of these type predicates on \tupe{inexact} numbers
is unreliable, since any inaccuracy may affect the result.
\end{note}

\begin{note}
In many implementations the \ide{complex?} procedure will be the same as
\ide{number?}, but unusual implementations may be able to represent
some irrational numbers exactly or may extend the number system to
support some kind of non-complex numbers.
\end{note}

\end{entry}

\begin{entry}{%
\proto{exact?}{ \vr{z}}{procedure}
\proto{inexact?}{ \vr{z}}{procedure}}

These numerical predicates provide tests for the exactness of a
quantity.  For any Scheme number, precisely one of these predicates
is true.

\begin{scheme}
(exact? 3.0)           \ev  \schfalse
(exact? \#e3.0)         \ev  \schtrue
(inexact? 3.)          \ev  \schtrue
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{exact-integer?}{ \vr{z}}{procedure}}

The conjunction of {\cf exact?} and {\cf integer?}, returns \schtrue{}
iff \vr{z} is both \tupe{exact} and an \tupe{integer}.
\end{entry}


\begin{entry}{%
\proto{finite?}{ \vr{z}}{inexact module procedure}}

{\cf Finite} returns \schtrue{} on all real numbers except
{\cf +inf.0}, {\cf -inf.0}, and {\cf +nan.0}, and on complex
numbers if and only if their real and imaginary parts are both finite.
Otherwise it returns \schfalse{}.

\begin{scheme}
(finite? 3)         \ev  \schtrue
(finite? +inf.0)       \ev  \schfalse
(finite? 3.0+inf.0i)   \ev  \schfalse
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{nan?}{ \vr{z}}{inexact module procedure}}

{\cf Nan} returns \schtrue{} on {\cf +nan.0}, and on any complex number
if and only if either its real part or its imaginary part is {\cf +nan.0}.
Otherwise it returns \schfalse{}.

\begin{scheme}
(nan? +nan.0)          \ev  \schtrue
(nan? +nan.0+5.0i)     \ev  \schtrue
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{=}{ \vri{z} \vrii{z} \vriii{z} \dotsfoo}{procedure}
\proto{<}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{procedure}
\proto{>}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{procedure}
\proto{<=}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{procedure}
\proto{>=}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{procedure}}

%- Some implementations allow these procedures to take many arguments, to 
%- facilitate range checks.  
These procedures return \schtrue{} if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing,
monotonically nondecreasing, or monotonically nonincreasing.

These predicates are required to be transitive.

\begin{note}
The traditional implementations of these predicates in Lisp-like
languages are not transitive.
\end{note}

\begin{note}
While it is not an error to compare \tupe{inexact} numbers using these
predicates, the results may be unreliable because a small inaccuracy
may affect the result; this is especially true of \ide{=} and \ide{zero?}.
When in doubt, consult a numerical analyst.
\end{note}

\end{entry}

\begin{entry}{%
\proto{zero?}{ \vr{z}}{procedure}
\proto{positive?}{ \vr{x}}{procedure}
\proto{negative?}{ \vr{x}}{procedure}
\proto{odd?}{ \vr{n}}{procedure}
\proto{even?}{ \vr{n}}{procedure}}

These numerical predicates test a number for a particular property,
returning \schtrue{} or \schfalse.  See note above.

\end{entry}

\begin{entry}{%
\proto{max}{ \vri{x} \vrii{x} \dotsfoo}{procedure}
\proto{min}{ \vri{x} \vrii{x} \dotsfoo}{procedure}}

These procedures return the maximum or minimum of their arguments.

\begin{scheme}
(max 3 4)              \ev  4    ; exact
(max 3.9 4)            \ev  4.0  ; inexact%
\end{scheme}

\begin{note}
If any argument is inexact, then the result will also be inexact (unless
the procedure can prove that the inaccuracy is not large enough to affect the
result, which is possible only in unusual implementations).  If {\cf min} or
{\cf max} is used to compare numbers of mixed exactness, and the numerical
value of the result cannot be represented as an inexact number without loss of
accuracy, then the procedure may report a violation of an implementation
restriction.
\end{note}

\end{entry}


\begin{entry}{%
\proto{+}{ \vri{z} \dotsfoo}{procedure}
\proto{*}{ \vri{z} \dotsfoo}{procedure}}

These procedures return the sum or product of their arguments.
%- These procedures are exactness preserving.

\begin{scheme}
(+ 3 4)                 \ev  7
(+ 3)                   \ev  3
(+)                     \ev  0
(* 4)                   \ev  4
(*)                     \ev  1%
\end{scheme} 
 
\end{entry}


\begin{entry}{%
\proto{-}{ \vri{z} \vrii{z}}{procedure}
\rproto{-}{ \vr{z}}{procedure}
\rproto{-}{ \vri{z} \vrii{z} \dotsfoo}{procedure}
\proto{/}{ \vri{z} \vrii{z}}{procedure}
\rproto{/}{ \vr{z}}{procedure}
\rproto{/}{ \vri{z} \vrii{z} \dotsfoo}{procedure}}

With two or more arguments, these procedures return the difference or
quotient of their arguments, associating to the left.  With one argument,
however, they return the additive or multiplicative inverse of their argument.
%- These procedures are exactness preserving, except that division may
%- coerce its result to inexact in implementations that do not support
%- \tupe{ratnum}s. 

\begin{scheme}
(- 3 4)                 \ev  -1
(- 3 4 5)               \ev  -6
(- 3)                   \ev  -3
(/ 3 4 5)               \ev  3/20
(/ 3)                   \ev  1/3%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{abs}{ x}{procedure}}

{\cf Abs} returns the absolute value of its argument.  
%- {\cf Abs} is exactness preserving when its argument is real.
\begin{scheme}
(abs -7)                \ev  7
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{floor/}{ \vri{n} \vrii{n}}{procedure}
\proto{floor-quotient}{ \vri{n} \vrii{n}}{procedure}
\proto{floor-remainder}{ \vri{n} \vrii{n}}{procedure}
\proto{ceiling/}{ \vri{n} \vrii{n}}{procedure}
\proto{ceiling-quotient}{ \vri{n} \vrii{n}}{procedure}
\proto{ceiling-remainder}{ \vri{n} \vrii{n}}{procedure}
\proto{truncate/}{ \vri{n} \vrii{n}}{procedure}
\proto{truncate-quotient}{ \vri{n} \vrii{n}}{procedure}
\proto{truncate-remainder}{ \vri{n} \vrii{n}}{procedure}
\proto{round/}{ \vri{n} \vrii{n}}{procedure}
\proto{round-quotient}{ \vri{n} \vrii{n}}{procedure}
\proto{round-remainder}{ \vri{n} \vrii{n}}{procedure}
\proto{euclidean/}{ \vri{n} \vrii{n}}{procedure}
\proto{euclidean-quotient}{ \vri{n} \vrii{n}}{procedure}
\proto{euclidean-remainder}{ \vri{n} \vrii{n}}{procedure}}

These procedures, all in the division module, implement
number-theoretic (integer) division.  \vrii{n} should be non-zero.
All fifteen procedures return integers.  The procedures compute a
quotient \vr{n_q} and remainder \vr{n_r} such that
$\vri{n} = \vrii{n} \vr{n_q} + \vr{n_r}$.  For each of the five
division operators, there are three procedures defined as follows:

\begin{scheme}
(\hyper{operator}/ \vri{n} \vrii{n})             \ev \vr{n_q} \vr{n_r}
(\hyper{operator}-quotient \vri{n} \vrii{n})     \ev \vr{n_q}
(\hyper{operator}-remainder \vri{n} \vrii{n})    \ev \vr{n_r}
\end{scheme}

The remainder \vr{n_r} is determined by the choice of integer
\vr{n_q}: $\vr{n_r} = \vri{n} - \vrii{n} \vr{n_q}$.  Each set of
operators uses a different choice of \vr{n_q}:

\begin{tabular}{l l}
\textbf{ceiling}   & $\vr{n_q} = \lceil\vri{n} / \vrii{n}\rceil$ \\
\textbf{floor}     & $\vr{n_q} = \lfloor\vri{n} / \vrii{n}\rfloor$ \\
\textbf{truncate}  & $\vr{n_q} = \text{truncate}(\vri{n} / \vrii{n})$ \\
\textbf{round}     & $\vr{n_q} = [\vri{n} / \vrii{n}]$ \\
\textbf{euclidean} & $\text{if } \vrii{n} > 0, \vr{n_q} = \lfloor\vri{n} / \vrii{n}\rfloor; \text{ if } \vrii{n} < 0, \vr{n_q} = \lceil\vri{n} / \vrii{n}\rceil$ \\
\end{tabular}

For any of the operators, and for integers \vri{n} and \vrii{n}
with \vrii{n} not equal to 0,
\begin{scheme}
     (= \vri{n} (+ (* \vrii{n} (\hyper{operator}-quotient \vri{n} \vrii{n}))
           (\hyper{operator}-remainder \vri{n} \vrii{n})))
                                 \ev  \schtrue%
\end{scheme}
provided all numbers involved in that computation are exact.

\end{entry}


\begin{entry}{%
\proto{quotient}{ \vri{n} \vrii{n}}{procedure}
\proto{remainder}{ \vri{n} \vrii{n}}{procedure}
\proto{modulo}{ \vri{n} \vrii{n}}{procedure}}

{\cf Quotient} and {\cf remainder} are equivalent to {\cf
  truncate-quotient} and {\cf truncate-remainder} respectively.  {\cf
  Modulo} is equivalent to {\cf floor-remainder}.

\begin{scheme}
(modulo 13 4)           \ev  1
(remainder 13 4)        \ev  1

(modulo -13 4)          \ev  3
(remainder -13 4)       \ev  -1

(modulo 13 -4)          \ev  -3
(remainder 13 -4)       \ev  1

(modulo -13 -4)         \ev  -1
(remainder -13 -4)      \ev  -1

(remainder -13 -4.0)    \ev  -1.0  ; inexact%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{gcd}{ \vri{n} \dotsfoo}{procedure}
\proto{lcm}{ \vri{n} \dotsfoo}{procedure}}

These procedures return the greatest common divisor or least common
multiple of their arguments.  The result is always non-negative.
%- These procedures are exactness preserving.

%%R4%% I added the inexact example.
\begin{scheme}
(gcd 32 -36)            \ev  4
(gcd)                   \ev  0
(lcm 32 -36)            \ev  288
(lcm 32.0 -36)          \ev  288.0  ; inexact
(lcm)                   \ev  1%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{numerator}{ \vr{q}}{procedure}
\proto{denominator}{ \vr{q}}{procedure}}

These procedures return the numerator or denominator of their
argument; the result is computed as if the argument was represented as
a fraction in lowest terms.  The denominator is always positive.  The
denominator of 0 is defined to be 1.
%- The remarks about denominators are new.
%- Clearly, they are exactness-preserving procedures.
\todo{More description and examples needed.}
\begin{scheme}
(numerator (/ 6 4))  \ev  3
(denominator (/ 6 4))  \ev  2
(denominator
  (exact->inexact (/ 6 4))) \ev 2.0%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{floor}{ x}{procedure}
\proto{ceiling}{ x}{procedure}
\proto{truncate}{ x}{procedure}
\proto{round}{ x}{procedure}
}

These procedures return integers.
\vest {\cf Floor} returns the largest integer not larger than \vr{x}.
{\cf Ceiling} returns the smallest integer not smaller than~\vr{x}.
{\cf Truncate} returns the integer closest to \vr{x} whose absolute
value is not larger than the absolute value of \vr{x}.  {\cf Round} returns the
closest integer to \vr{x}, rounding to even when \vr{x} is halfway between two
integers.

\begin{rationale}
{\cf Round} rounds to even for consistency with the default rounding
mode specified by the IEEE floating point standard.
\end{rationale}

\begin{note}
If the argument to one of these procedures is inexact, then the result
will also be inexact.  If an exact value is needed, the
result should be passed to the {\cf inexact->exact} procedure.
\end{note}

\begin{scheme}
(floor -4.3)          \ev  -5.0
(ceiling -4.3)        \ev  -4.0
(truncate -4.3)       \ev  -4.0
(round -4.3)          \ev  -4.0

(floor 3.5)           \ev  3.0
(ceiling 3.5)         \ev  4.0
(truncate 3.5)        \ev  3.0
(round 3.5)           \ev  4.0  ; inexact

(round 7/2)           \ev  4    ; exact
(round 7)             \ev  7%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{rationalize}{ x y}{procedure}
%- \proto{rationalize}{ x}{procedure}
}

{\cf Rationalize} returns the {\em simplest} rational number
differing from \vr{x} by no more than \vr{y}.  A rational number $r_1$ is
{\em simpler} \mainindex{simplest rational} than another rational number
$r_2$ if $r_1 = p_1/q_1$ and $r_2 = p_2/q_2$ (in lowest terms) and $|p_1|
\leq |p_2|$ and $|q_1| \leq |q_2|$.  Thus $3/5$ is simpler than $4/7$.
Although not all rationals are comparable in this ordering (consider $2/7$
and $3/5$) any interval contains a rational number that is simpler than
every other rational number in that interval (the simpler $2/5$ lies
between $2/7$ and $3/5$).  Note that $0 = 0/1$ is the simplest rational of
all.

\begin{scheme}
(rationalize
  (inexact->exact .3) 1/10)  \ev 1/3    ; exact
(rationalize .3 1/10)        \ev \#i1/3  ; inexact%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{exp}{ \vr{z}}{inexact module procedure}
\proto{log}{ \vr{z}}{inexact module procedure}
\proto{sin}{ \vr{z}}{inexact module procedure}
\proto{cos}{ \vr{z}}{inexact module procedure}
\proto{tan}{ \vr{z}}{inexact module procedure}
\proto{asin}{ \vr{z}}{inexact module procedure}
\proto{acos}{ \vr{z}}{inexact module procedure}
\proto{atan}{ \vr{z}}{inexact module procedure}
\rproto{atan}{ \vr{y} \vr{x}}{inexact module procedure}}

These procedures 
compute the usual transcendental functions.  {\cf Log}
computes the natural logarithm of \vr{z} (not the base ten logarithm).
{\cf Asin}, {\cf acos}, and {\cf atan} compute arcsine ($\sin^{-1}$),
arccosine ($\cos^{-1}$), and arctangent ($\tan^{-1}$), respectively.
The two-argument variant of {\cf atan} computes {\tt (angle
(make-rectangular \vr{x} \vr{y}))} (see below), even in implementations
that don't support general complex numbers.

In general, the mathematical functions log, arcsine, arccosine, and
arctangent are multiply defined.
The value of $\log z$ is defined to be the one whose imaginary
part lies in the range from $-\pi$ (exclusive) to $\pi$ (inclusive).
$\log 0$ is undefined.
With $\log$ defined this way, the values of $\sin^{-1} z$, $\cos^{-1} z$,
and $\tan^{-1} z$ are according to the following formul\ae:
$$\sin^{-1} z = -i \log (i z + \sqrt{1 - z^2})$$
$$\cos^{-1} z = \pi / 2 - \sin^{-1} z$$
$$\tan^{-1} z = (\log (1 + i z) - \log (1 - i z)) / (2 i)$$

The above specification follows~\cite{CLtL}, which in turn
cites~\cite{Penfield81}; refer to these sources for more detailed
discussion of branch cuts, boundary conditions, and implementation of
these functions.  When it is possible these procedures produce a real
result from a real argument.

%%R4%%
\todo{The cited references are likely to change their branch cuts
soon to allow for the possibility of distinct positive and negative
zeroes, as in IEEE floating point.  We may not want to follow those
changes, since we may want a complex number with zero imaginary part
(whether positive or negative zero) to be treated as a real.  I don't
think there are any better standards for complex arithmetic than the
ones cited, so we're really on our own here.}

\end{entry}


\begin{entry}{%
\proto{sqrt}{ \vr{z}}{inexact module procedure}}

Returns the principal square root of \vr{z}.  The result will have
either positive real part, or zero real part and non-negative imaginary
part.
\end{entry}


\begin{entry}{%
\proto{exact-integer-sqrt}{ k}{procedure}}

Returns two non-negative exact integer objects $s$ and $r$ where
$\var{k} = s^2 + r$ and $\var{k} < (s+1)^2$.

\begin{scheme}
(exact-integer-sqrt 4) \ev 2 0
(exact-integer-sqrt 5) \ev 2 1
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{expt}{ \vri{z} \vrii{z}}{procedure}}

Returns \vri{z} raised to the power \vrii{z}.  For $z_1 \neq 0$
$${z_1}^{z_2} = e^{z_2 \log {z_1}}$$
$0^z$ is 1 if $z = 0$ and 0 otherwise.
\end{entry}

%- \begin{entry}{%- 
%- \proto{approximate}{ z x}{procedure}}
%- 
%- Returns an approximation to \vr{z} in a representation whose precision is
%- the same as that 
%- of the representation of \vr{x}, which must be an inexact number.  The
%- result is always inexact.
%- 
%- \begin{scheme}
%- (approximate 3.1415926535 1F10)
%-         \ev  3.14159F0
%- (approximate 3.1415926535 \#I65535)
%-         \ev \#I3
%- (approximate 3.14F0 1L8)
%-         \ev  3.14L0
%- (approximate 3.1415926535F0 1L8)
%-         \ev  3.14159L0
%- \end{scheme}
%- \end{entry}



\begin{entry}{%
\proto{make-rectangular}{ \vri{x} \vrii{x}}{complex module procedure}
\proto{make-polar}{ \vriii{x} \vriv{x}}{complex module procedure}
\proto{real-part}{ \vr{z}}{complex module procedure}
\proto{imag-part}{ \vr{z}}{complex module procedure}
\proto{magnitude}{ \vr{z}}{complex module procedure}
\proto{angle}{ \vr{z}}{complex module procedure}}

Suppose \vri{x}, \vrii{x}, \vriii{x}, and \vriv{x} are
real numbers and \vr{z} is a complex number such that
 $$ \vr{z} = \vri{x} + \vrii{x}\hbox{$i$}
 = \vriii{x} \cdot e^{{\displaystyle{\hbox{$i$}} \vriv{x}}}$$
Then
\begin{scheme}
(make-rectangular \vri{x} \vrii{x}) \ev \vr{z}
(make-polar \vriii{x} \vriv{x})     \ev \vr{z}
(real-part \vr{z})                  \ev \vri{x}
(imag-part \vr{z})                  \ev \vrii{x}
(magnitude \vr{z})                  \ev $|\vriii{x}|$
(angle \vr{z})                      \ev $x_{angle}$
\end{scheme}
where $-\pi < x_{angle} \le \pi$ with $x_{angle} = \vriv{x} + 2\pi n$
for some integer $n$.

\begin{rationale}
{\cf Magnitude} is the same as \ide{abs} for a real argument,
but {\cf abs} is in the {\cf base} module, whereas
{\cf magnitude} is in the optional {\cf complex} module.
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{exact->inexact}{ \vr{z}}{procedure}
\proto{inexact->exact}{ \vr{z}}{procedure}}

{\cf Exact\coerce{}inexact} returns an \tupe{inexact} representation of \vr{z}.
The value returned is the
\tupe{inexact} number that is numerically closest to the argument.  
%%R4%%For
%\tupe{exact} arguments which have no reasonably close \tupe{inexact} equivalent,
%it is permissible to signal an error.
For inexact arguments, the result is the same as the argument. For exact
complex numbers, the result is a complex number whose real and imaginary
parts are the result of applying {\cf exact\coerce{}inexact} to the real
and imaginary parts of the argument, respectively.
If an \tupe{exact} argument has no reasonably close \tupe{inexact} equivalent,
then a violation of an implementation restriction may be reported.

{\cf Inexact\coerce{}exact} returns an \tupe{exact} representation of
\vr{z}.  The value returned is the \tupe{exact} number that is numerically
closest to the argument.
%%R4%%  For \tupe{inexact} arguments which have no
%reasonably close \tupe{exact} equivalent, it is permissible to signal
%an error.
For exact arguments, the result is the same as the argument. For inexact
non-integral real arguments, the implementation may return a rational
approximation, or may report an implementation violation. For inexact
complex arguments, the result is a complex number whose real and
imaginary parts are result of applying {\cf inexact\coerce{}exact} to the
real and imaginary parts of the argument, respectively.
If an \tupe{inexact} argument has no reasonably close \tupe{exact} equivalent,
then a violation of an implementation restriction may be reported.

%%R%% I moved this to the section on implementation restrictions.
%For any implementation that supports \tupe{inexact} quantities,
%there is a subset of the integers for which there are both \tupe{exact} and
%\tupe{inexact} representations.  This subset must include the non-negative
%integers up to a limit specified by the implementation.  The limit
%must be big enough to represent all digits in reasonable radices, and
%may correspond to some natural word size for the implementation.  For
%such integers, these procedures implement the natural one-to-one
%correspondence between the representations.

These procedures implement the natural one-to-one correspondence between
\tupe{exact} and \tupe{inexact} integers throughout an
implementation-dependent range.  See section~\ref{restrictions}.

\begin{note}
The names {\cf exact\coerce{}inexact} and {\cf
inexact\coerce{}exact} are historical anomalies; the argument to each of
these procedures may be either exact or inexact.
\end{note}

\end{entry}

\medskip

\subsection{Numerical input and output}

\begin{entry}{%
\proto{number->string}{ z}{procedure}
\rproto{number->string}{ z radix}{procedure}}

\vr{Radix} must be an exact integer, either 2, 8, 10, or 16.  If omitted,
\vr{radix} defaults to 10.
The procedure {\cf number\coerce{}string} takes a
number and a radix and returns as a string an external representation of
the given number in the given radix such that
\begin{scheme}
(let ((number \vr{number})
      (radix \vr{radix}))
  (eqv? number
        (string->number (number->string number
                                        radix)
                        radix)))
\end{scheme}
is true.  It is an error if no possible result makes this expression true.

If \vr{z} is inexact, the radix is 10, and the above expression
can be satisfied by a result that contains a decimal point,
then the result contains a decimal point and is expressed using the
minimum number of digits (exclusive of exponent and trailing
zeroes) needed to make the above expression
true~\cite{howtoprint,howtoread};
otherwise the format of the result is unspecified.

The result returned by {\cf number\coerce{}string}
never contains an explicit radix prefix.

\begin{note}
The error case can occur only when \vr{z} is not a complex number
or is a complex number with a non-rational real or imaginary part.
\end{note}

\begin{rationale}
If \vr{z} is an inexact number represented using flonums, and
the radix is 10, then the above expression is normally satisfied by
a result containing a decimal point.  The unspecified case
allows for infinities, NaNs, and non-flonum representations.
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{string->number}{ string}{procedure}
\rproto{string->number}{ string radix}{procedure}}

%%R4%% I didn't include the (string->number string radix exactness)
% case, since I haven't heard any resolution of the coding to be used
% for the third argument.

Returns a number of the maximally precise representation expressed by the
given \vr{string}.  \vr{Radix} must be an exact integer, either 2, 8, 10,
or 16.  If supplied, \vr{radix} is a default radix that may be overridden
by an explicit radix prefix in \vr{string} (e.g. {\tt "\#o177"}).  If \vr{radix}
is not supplied, then the default radix is 10.  If \vr{string} is not
a syntactically valid notation for a number, then {\cf string->number}
returns \schfalse{}.

\begin{scheme}
(string->number "100")        \ev  100
(string->number "100" 16)     \ev  256
(string->number "1e2")        \ev  100.0
(string->number "15\#\#")       \ev  1500.0%
\end{scheme}

\begin{note}
The domain of {\cf string->number} may be restricted by implementations
in the following ways.  {\cf String->number} is permitted to return
\schfalse{} whenever \vr{string} contains an explicit radix prefix.
If all numbers supported by an implementation are real, then
{\cf string->number} is permitted to return \schfalse{} whenever
\vr{string} uses the polar or rectangular notations for complex
numbers.  If all numbers are integers, then
{\cf string->number} may return \schfalse{} whenever
the fractional notation is used.  If all numbers are exact, then
{\cf string->number} may return \schfalse{} whenever
an exponent marker or explicit exactness prefix is used, or if
a {\tt \#} appears in place of a digit.  If all inexact
numbers are integers, then
{\cf string->number} may return \schfalse{} whenever
a decimal point is used.
\end{note}

\end{entry}

\section{Other data types}

This section describes operations on some of Scheme's non-numeric data types:
booleans, pairs, lists, symbols, characters, strings and vectors.

\subsection{Booleans}
\label{booleansection}

The standard boolean objects for true and false are written as
\schtrue{} and \schfalse.\sharpindex{t}\sharpindex{f}  What really
matters, though, are the objects that the Scheme conditional expressions
({\cf if}, {\cf cond}, {\cf and}, {\cf or}, {\cf do}) treat as
true\index{true} or false\index{false}.  The phrase ``a true value''\index{true}
(or sometimes just ``true'') means any object treated as true by the
conditional expressions, and the phrase ``a false value''\index{false} (or
``false'') means any object treated as false by the conditional expressions.

\vest Of all the standard Scheme values, only \schfalse{}
% is guaranteed to count
counts as false in conditional expressions.
%  It is not
% specified whether the empty list\index{empty list} counts as false
% or as true in conditional expressions.
Except for \schfalse{},
% and possibly the empty list,
all standard Scheme values, including \schtrue,
pairs, the empty list, symbols, numbers, strings, vectors, and procedures,
count as true.

%\begin{note}
%In some implementations the empty list counts as false, contrary
%to the above.
%Nonetheless a few examples in this report assume that the
%empty list counts as true, as in \cite{IEEEScheme}.
%\end{note}

% \begin{rationale}
% For historical reasons some implementations regard \schfalse{} and the
% empty list as the same object.  These implementations therefore cannot
% make the empty list count as true in conditional expressions.
% \end{rationale}

\begin{note}
Programmers accustomed to other dialects of Lisp should be aware that
Scheme distinguishes both \schfalse{} and the empty list \index{empty list}
from the symbol \ide{nil}.
\end{note}

\vest Boolean constants evaluate to themselves, so they do not need to be quoted
in programs.

\begin{scheme}
\schtrue         \ev  \schtrue
\schfalse        \ev  \schfalse
'\schfalse       \ev  \schfalse%
\end{scheme}


\begin{entry}{%
\proto{not}{ obj}{procedure}}

{\cf Not} returns \schtrue{} if \var{obj} is false, and returns
\schfalse{} otherwise.

\begin{scheme}
(not \schtrue)   \ev  \schfalse
(not 3)          \ev  \schfalse
(not (list 3))   \ev  \schfalse
(not \schfalse)  \ev  \schtrue
(not '())        \ev  \schfalse
(not (list))     \ev  \schfalse
(not 'nil)       \ev  \schfalse%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{boolean?}{ obj}{procedure}}

{\cf Boolean?} returns \schtrue{} if \var{obj} is either \schtrue{} or
\schfalse{} and returns \schfalse{} otherwise.

\begin{scheme}
(boolean? \schfalse)  \ev  \schtrue
(boolean? 0)          \ev  \schfalse
(boolean? '())        \ev  \schfalse%
\end{scheme}

\end{entry}

 
\subsection{Pairs and lists}
\label{listsection}

A \defining{pair} (sometimes called a \defining{dotted pair}) is a
record structure with two fields called the car and cdr fields (for
historical reasons).  Pairs are created by the procedure {\cf cons}.
The car and cdr fields are accessed by the procedures {\cf car} and
{\cf cdr}.  The car and cdr fields are assigned by the procedures
{\cf set-car!}\ and {\cf set-cdr!}.

Pairs are used primarily to represent lists.  A list can
be defined recursively as either the empty list\index{empty list} or a pair whose
cdr is a list.  More precisely, the set of lists is defined as the smallest
set \var{X} such that

\begin{itemize}
\item The empty list is in \var{X}.
\item If \var{list} is in \var{X}, then any pair whose cdr field contains
      \var{list} is also in \var{X}.
\end{itemize}

The objects in the car fields of successive pairs of a list are the
elements of the list.  For example, a two-element list is a pair whose car
is the first element and whose cdr is a pair whose car is the second element
and whose cdr is the empty list.  The length of a list is the number of
elements, which is the same as the number of pairs.

The empty list\mainindex{empty list} is a special object of its own type
(it is not a pair); it has no elements and its length is zero.

\begin{note}
The above definitions imply that all lists have finite length and are
terminated by the empty list.
\end{note}

The most general notation (external representation) for Scheme pairs is
the ``dotted'' notation \hbox{\cf (\vari{c} .\ \varii{c})} where
\vari{c} is the value of the car field and \varii{c} is the value of the
cdr field.  For example {\cf (4 .\ 5)} is a pair whose car is 4 and whose
cdr is 5.  Note that {\cf (4 .\ 5)} is the external representation of a
pair, not an expression that evaluates to a pair.

A more streamlined notation can be used for lists: the elements of the
list are simply enclosed in parentheses and separated by spaces.  The
empty list\index{empty list} is written {\tt()} .  For example,

\begin{scheme}
(a b c d e)%
\end{scheme}

and

\begin{scheme}
(a . (b . (c . (d . (e . ())))))%
\end{scheme}

are equivalent notations for a list of symbols.

A chain of pairs not ending in the empty list is called an
\defining{improper list}.  Note that an improper list is not a list.
The list and dotted notations can be combined to represent
improper lists:

\begin{scheme}
(a b c . d)%
\end{scheme}

is equivalent to

\begin{scheme}
(a . (b . (c . d)))%
\end{scheme}

Whether a given pair is a list depends upon what is stored in the cdr
field.  When the \ide{set-cdr!} procedure is used, an object can be a
list one moment and not the next:

\begin{scheme}
(define x (list 'a 'b 'c))
(define y x)
y                       \ev  (a b c)
(list? y)               \ev  \schtrue
(set-cdr! x 4)          \ev  \unspecified
x                       \ev  (a . 4)
(eqv? x y)              \ev  \schtrue
y                       \ev  (a . 4)
(list? y)               \ev  \schfalse
(set-cdr! x x)          \ev  \unspecified
(list? x)               \ev  \schfalse%
\end{scheme}

%It is often convenient to speak of a homogeneous list of objects
%of some particular data type, as for example \hbox{\cf (1 2 3)} is a list of
%integers.  To be more precise, suppose \var{D} is some data type.  (Any
%predicate defines a data type consisting of those objects of which the
%predicate is true.)  Then
%
%\begin{itemize}
%\item The empty list is a list of \var{D}.
%\item If \var{list} is a list of \var{D}, then any pair whose cdr is
%      \var{list} and whose car is an element of the data type \var{D} is also a
%      list of \var{D}.
%\item There are no other lists of \var{D}.
%\end{itemize}

Within literal expressions and representations of objects read by the
\ide{read} procedure, the forms \singlequote\hyper{datum}\schindex{'},
\backquote\hyper{datum}, {\tt,}\hyper{datum}\schindex{,}, and
{\tt,@}\hyper{datum} denote two-ele\-ment lists whose first elements are
the symbols \ide{quote}, \ide{quasiquote}, \hbox{\ide{unquote}}, and
\ide{unquote-splicing}, respectively.  The second element in each case
is \hyper{datum}.  This convention is supported so that arbitrary Scheme
programs may be represented as lists.  \todo{Can or need this be stated
more carefully?} That is, according to Scheme's grammar, every
\meta{expression} is also a \meta{datum} (see section~\ref{datum}).
Among other things, this permits the use of the {\cf read} procedure to
parse Scheme programs.  See section~\ref{externalreps}. 
 

\begin{entry}{%
\proto{pair?}{ obj}{procedure}}

{\cf Pair?} returns \schtrue{} if \var{obj} is a pair, and otherwise
returns \schfalse.

\begin{scheme}
(pair? '(a . b))        \ev  \schtrue
(pair? '(a b c))        \ev  \schtrue
(pair? '())             \ev  \schfalse
(pair? '\#(a b))         \ev  \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{cons}{ \vari{obj} \varii{obj}}{procedure}}

Returns a newly allocated pair whose car is \vari{obj} and whose cdr is
\varii{obj}.  The pair is guaranteed to be different (in the sense of
{\cf eqv?}) from every existing object.

\begin{scheme}
(cons 'a '())           \ev  (a)
(cons '(a) '(b c d))    \ev  ((a) b c d)
(cons "a" '(b c))       \ev  ("a" b c)
(cons 'a 3)             \ev  (a . 3)
(cons '(a b) 'c)        \ev  ((a b) . c)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{car}{ pair}{procedure}}

\nodomain{\var{Pair} must be a pair.}
Returns the contents of the car field of \var{pair}.  Note that it is an
error to take the car of the empty list\index{empty list}.

\begin{scheme}
(car '(a b c))          \ev  a
(car '((a) b c d))      \ev  (a)
(car '(1 . 2))          \ev  1
(car '())               \ev  \scherror%
\end{scheme}
 
\end{entry}


\begin{entry}{%
\proto{cdr}{ pair}{procedure}}

\nodomain{\var{Pair} must be a pair.}
Returns the contents of the cdr field of \var{pair}.
Note that it is an error to take the cdr of the empty list.

\begin{scheme}
(cdr '((a) b c d))      \ev  (b c d)
(cdr '(1 . 2))          \ev  2
(cdr '())               \ev  \scherror%
\end{scheme}
 
\end{entry}


\begin{entry}{%
\proto{set-car!}{ pair obj}{procedure}}

\nodomain{\var{Pair} must be a pair.}  
Stores \var{obj} in the car field of \var{pair}.
The value returned by {\cf set-car!}\ is unspecified.  % <!>
%This procedure can be very confusing if used indiscriminately.

\begin{scheme}
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))
(set-car! (f) 3)             \ev  \unspecified
(set-car! (g) 3)             \ev  \scherror%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{set-cdr!}{ pair obj}{procedure}}

\nodomain{\var{Pair} must be a pair.}
Stores \var{obj} in the cdr field of \var{pair}.
The value returned by {\cf set-cdr!}\ is unspecified.  % <!>
%This procedure can be very confusing if used indiscriminately.

\end{entry}

\setbox0\hbox{\tt(cadr \var{pair})}
\setbox1\hbox{procedure}


\begin{entry}{%
\proto{caar}{ pair}{procedure}
\proto{cadr}{ pair}{procedure}
\pproto{\hbox to 1\wd0 {\hfil$\vdots$\hfil}}{\hbox to 1\wd1 {\hfil$\vdots$\hfil}}
\proto{cdddar}{ pair}{procedure}
\proto{cddddr}{ pair}{procedure}}

These procedures are compositions of {\cf car} and {\cf cdr}, where
for example {\cf caddr} could be defined by

\begin{scheme}
(define caddr (lambda (x) (car (cdr (cdr x))))){\rm.}%
\end{scheme}

Arbitrary compositions, up to four deep, are provided.  There are
twenty-eight of these procedures in all.

\end{entry}


\begin{entry}{%
\proto{null?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is the empty list\index{empty list},
otherwise returns \schfalse.

% \begin{note}
% In implementations in which the empty
% list is the same as \schfalse{}, {\cf null?} will return \schtrue{}
% if \var{obj} is \schfalse{}.
% \end{note}
 
\end{entry}

\begin{entry}{%
\proto{list?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a list, otherwise returns \schfalse{}.
By definition, all lists have finite length and are terminated by
the empty list.

\begin{scheme}
        (list? '(a b c))     \ev  \schtrue
        (list? '())          \ev  \schtrue
        (list? '(a . b))     \ev  \schfalse
        (let ((x (list 'a)))
          (set-cdr! x x)
          (list? x))         \ev  \schfalse%
\end{scheme}

\todo{Do we need to emphasize the following note?}

%% \begin{note}
%%   The {\cf list?} procedure must terminate and return \schfalse{} if \var{obj}
%%   contains cycles.
%% \end{note}
\end{entry}

\begin{entry}{%
\proto{make-list}{ k}{procedure}
\rproto{make-list}{ k fill}{procedure}}

Returns a newly allocated list of \var{k} elements.  If a second
argument is given, then each element is initialized to \var{fill}.
Otherwise the initial contents of each element is unspecified.

\end{entry}



\begin{entry}{%
\proto{list}{ \var{obj} \dotsfoo}{procedure}}

Returns a newly allocated list of its arguments.

\begin{scheme}
(list 'a (+ 3 4) 'c)            \ev  (a 7 c)
(list)                          \ev  ()%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{length}{ list}{procedure}}

\nodomain{\var{List} must be a list.}
Returns the length of \var{list}.

\begin{scheme}
(length '(a b c))               \ev  3
(length '(a (b) (c d e)))       \ev  3
(length '())                    \ev  0%
\end{scheme}

\todo{Do we need to emphasize the following note?}

%% \begin{note}
%%   The {\cf length} procedure must detect and signal an error if its
%%   argument contains cycles.
%% \end{note}
\end{entry}


\begin{entry}{%
\proto{append}{ list \dotsfoo}{procedure}}

\nodomain{All \var{list}s should be lists.}
Returns a list consisting of the elements of the first \var{list}
followed by the elements of the other \var{list}s.

\begin{scheme}
(append '(x) '(y))              \ev  (x y)
(append '(a) '(b c d))          \ev  (a b c d)
(append '(a (b)) '((c)))        \ev  (a (b) (c))%
\end{scheme}

The resulting list is always newly allocated, except that it shares
structure with the last \var{list} argument.  The last argument may
actually be any object; an improper list results if the last argument is not a
proper list.  \todo{This is pretty awkward.  I should get Bartley to fix this.}

\begin{scheme}
(append '(a b) '(c . d))        \ev  (a b c . d)
(append '() 'a)                 \ev  a%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{reverse}{ list}{procedure}}

\nodomain{\var{List} must be a list.}
Returns a newly allocated list consisting of the elements of \var{list}
in reverse order.

\begin{scheme}
(reverse '(a b c))              \ev  (c b a)
(reverse '(a (b c) d (e (f))))  \lev  ((e (f)) d (b c) a)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{list-tail}{ list \vr{k}}{procedure}}

Returns the sublist of \var{list} obtained by omitting the first \vr{k}
elements.  It is an error if \var{list} has fewer than \vr{k} elements.
{\cf List-tail} could be defined by

\begin{scheme}
(define list-tail
  (lambda (x k)
    (if (zero? k)
        x
        (list-tail (cdr x) (- k 1)))))%
\end{scheme} 
\end{entry}


\begin{entry}{%
\proto{list-ref}{ list \vr{k}}{procedure}}

Returns the \vr{k}th element of \var{list}.  (This is the same
as the car of {\tt(list-tail \var{list} \vr{k})}.)
It is an error if \var{list} has fewer than \vr{k} elements.

\begin{scheme}
(list-ref '(a b c d) 2)                 \ev  c
(list-ref '(a b c d)
          (inexact->exact (round 1.8))) \lev  c%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{list-set!}{ list k obj}{procedure}}

\domain{\vr{k} must be a valid index of \var{list}.}
{\cf List-set!} stores \var{obj} in element \vr{k} of \var{list}.
The value returned by {\cf list-set!}\ is unspecified.  % <!>

\begin{scheme}
(let ((lst (list 0 '(2 2 2 2) "Anna")))
  (list-set! lst 1 '("Sue" "Sue"))
  vec)      \lev  (0 ("Sue" "Sue") "Anna")

(list-set! '(0 1 2) 1 "doe")  \lev  \scherror  ; constant list%
\end{scheme}
\end{entry}


%\begin{entry}{%
%\proto{last-pair}{ list}{procedure}}
%
%Returns the last pair in the nonempty, possibly improper, list \var{list}.
%{\cf Last-pair} could be defined by
%
%\begin{scheme}
%(define last-pair
%  (lambda (x)
%    (if (pair? (cdr x))
%        (last-pair (cdr x))
%        x)))%
%\end{scheme} 
% 
%\end{entry}


\begin{entry}{%
\proto{memq}{ obj list}{procedure}
\proto{memv}{ obj list}{procedure}
\proto{member}{ obj list}{procedure}
\proto{member}{ obj list compare}{procedure}}

These procedures return the first sublist of \var{list} whose car is
\var{obj}, where the sublists of \var{list} are the non-empty lists
returned by {\tt (list-tail \var{list} \var{k})} for \var{k} less
than the length of \var{list}.  If
\var{obj} does not occur in \var{list}, then \schfalse{} (not the empty list) is
returned.  {\cf Memq} uses {\cf eq?}\ to compare \var{obj} with the elements of
\var{list}, while {\cf memv} uses {\cf eqv?} and 
{\cf member} uses \var{compare} if given and {\cf equal?} otherwise.

\begin{scheme}
(memq 'a '(a b c))              \ev  (a b c)
(memq 'b '(a b c))              \ev  (b c)
(memq 'a '(b c d))              \ev  \schfalse
(memq (list 'a) '(b (a) c))     \ev  \schfalse
(member (list 'a)
        '(b (a) c))             \ev  ((a) c)
(member "B"
        '("a" "b" "c")
        string-ci=?)            \ev  ("b" "c")
(memq 101 '(100 101 102))       \ev  \unspecified
(memv 101 '(100 101 102))       \ev  (101 102)%
\end{scheme} 
 
\end{entry}


\begin{entry}{%
\proto{assq}{ obj alist}{procedure}
\proto{assv}{ obj alist}{procedure}
\proto{assoc}{ obj alist}{procedure}
\proto{assoc}{ obj alist compare}{procedure}}

\domain{\var{Alist} (for ``association list'') must be a list of
pairs.}  These procedures find the first pair in \var{alist} whose car field is \var{obj},
and returns that pair.  If no pair in \var{alist} has \var{obj} as its
car, then \schfalse{} (not the empty list) is returned.  {\cf Assq} uses
{\cf eq?}\ to compare \var{obj} with the car fields of the pairs in \var{alist},
while {\cf assv} uses {\cf eqv?}\ and {\cf assoc} uses \var{compare} if given
and {\cf equal?} otherwise.

\begin{scheme}
(define e '((a 1) (b 2) (c 3)))
(assq 'a e)     \ev  (a 1)
(assq 'b e)     \ev  (b 2)
(assq 'd e)     \ev  \schfalse
(assq (list 'a) '(((a)) ((b)) ((c))))
                \ev  \schfalse
(assoc (list 'a) '(((a)) ((b)) ((c))))   
                           \ev  ((a))
(assq 5 '((2 3) (5 7) (11 13)))    
                           \ev  \unspecified
(assv 5 '((2 3) (5 7) (11 13)))    
                           \ev  (5 7)%
\end{scheme}


\begin{rationale}
Although they are ordinarily used as predicates,
{\cf memq}, {\cf memv}, {\cf member}, {\cf assq}, {\cf assv}, and {\cf assoc} do not
have question marks in their names because they return useful values rather
than just \schtrue{} or \schfalse{}.
\end{rationale}
\end{entry}

\begin{entry}{%
\proto{list-copy}{ list}{procedure}}

Returns a newly allocated copy of the given \var{list}.

\end{entry}


\subsection{Symbols}
\label{symbolsection}

Symbols are objects whose usefulness rests on the fact that two
symbols are identical (in the sense of {\cf eqv?}) if and only if their
names are spelled the same way.  For instance, they may be used
the way enumerated values are used in other languages.

\vest The rules for writing a symbol are exactly the same as the rules for
writing an identifier; see sections~\ref{syntaxsection}
and~\ref{identifiersyntax}.

\vest It is guaranteed that any symbol that has been returned as part of
a literal expression, or read using the {\cf read} procedure, and
subsequently written out using the {\cf write} procedure, will read back
in as the identical symbol (in the sense of {\cf eqv?}).
%% The {\cf string\coerce{}symbol} procedure, however, can create symbols for
%% which this write/read invariance may not hold because their names
%% contain special characters or letters in the non-standard case.

\begin{note}
%% Some implementations of Scheme have a feature known as ``slashification''
%% in order to guarantee write/read invariance for all symbols, but
%% historically the most important use of this feature has been to
%% compensate for the lack of a string data type.
%\vest
Some implementations have values known as ``uninterned symbols'', which
defeat write/read invariance,
and also generate exceptions to the rule that two symbols are the same
if and only if their names are spelled the same.
\end{note}


\begin{entry}{%
\proto{symbol?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a symbol, otherwise returns \schfalse.

\begin{scheme}
(symbol? 'foo)          \ev  \schtrue
(symbol? (car '(a b)))  \ev  \schtrue
(symbol? "bar")         \ev  \schfalse
(symbol? 'nil)          \ev  \schtrue
(symbol? '())           \ev  \schfalse
(symbol? \schfalse)     \ev  \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{symbol->string}{ symbol}{procedure}}

Returns the name of \var{symbol} as a string.  It is an error
to apply mutation procedures like \ide{string-set!} to strings returned
by this procedure.

\begin{scheme}
(symbol->string 'flying-fish)     
                                  \ev  "flying-fish"
(symbol->string 'Martin)          \ev  "Martin"
(symbol->string
   (string->symbol "Malvina"))     
                                  \ev  "Malvina"%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{string->symbol}{ string}{procedure}}

Returns the symbol whose name is \var{string}.  This procedure can
create symbols with names containing special characters that would
require escaping when written.

\begin{scheme}
%(eq? 'mISSISSIppi 'mississippi)  \lev  \schtrue
(string->symbol "mISSISSIppi")  \lev%
  'mISSISSIppi
(eq? 'bitBlt (string->symbol "bitBlt"))     \lev  \schtrue
(eq? 'JollyWog
     (string->symbol
       (symbol->string 'JollyWog)))  \lev  \schtrue
(string=? "K. Harper, M.D."
          (symbol->string
            (string->symbol "K. Harper, M.D.")))  \lev  \schtrue%
\end{scheme}

\end{entry}


\subsection{Characters}
\label{charactersection}

Characters are objects that represent printed characters such as
letters and digits.  
All Scheme implementations must support at least the ASCII character
repertoire: that is, Unicode characters U+0000 through U+007F.
Implementations may support any other Unicode characters they see fit,
and may also support non-Unicode characters as well.
Except as otherwise specified, the result of applying any of the
following procedures to a non-Unicode character is implementation-dependent.
%There is no requirement that the data type of
%characters be disjoint from other data types; implementations are
%encouraged to have a separate character data type, but may choose to
%represent characters as integers, strings, or some other type.
Characters are written using the notation \sharpsign\backwhack\hyper{character}
or \sharpsign\backwhack\hyper{character name} or
\sharpsign\backwhack{}x\meta{hex scalar value}.
For example:

$$
\begin{tabular}{ll}
{\tt \#\backwhack{}a}&; lower case letter\\
{\tt \#\backwhack{}A}&; upper case letter\\
{\tt \#\backwhack{}(}&; left parenthesis\\
{\tt \#\backwhack{} }&; the space character\\
{\tt \#\backwhack{}space}&; the preferred way to write a space\\
{\tt \#\backwhack{}tab}&; the tab character, \textrm{U+0009}\\
{\tt \#\backwhack{}newline}&; the linefeed character, \textrm{U+000A}\\
{\tt \#\backwhack{}return}&; the return character, \textrm{U+000D}\\
{\tt \#\backwhack{}null}&; the null character, \textrm{U+0000}\\
{\tt \#\backwhack{}alarm}&; \textrm{U+0007}\\
{\tt \#\backwhack{}backspace}&; \textrm{U+0008}\\
{\tt \#\backwhack{}escape}&; \textrm{U+001B}\\
{\tt \#\backwhack{}delete}&; \textrm{U+007F}\\
{\tt \#\backwhack{}x03BB}&; $\lambda$ (if supported)\\
\end{tabular}
$$

Case is significant in \sharpsign\backwhack\hyper{character}, and in
\sharpsign\backwhack{\rm$\langle$character name$\rangle$},
but not in {\cf\sharpsign\backwhack{}x}\meta{hex scalar value}.  
If \hyper{character} in
\sharpsign\backwhack\hyper{character} is alphabetic, then the character
following \hyper{character} must be a delimiter character such as a
space or parenthesis.  This rule resolves the ambiguous case where, for
example, the sequence of characters ``{\tt\sharpsign\backwhack space}''
could be taken to be either a representation of the space character or a
representation of the character ``{\tt\sharpsign\backwhack s}'' followed
by a representation of the symbol ``{\tt pace}.''

\todo{Fix}
Characters written in the \sharpsign\backwhack{} notation are self-evaluating.
That is, they do not have to be quoted in programs.  
%The \sharpsign\backwhack{}
%notation is not an essential part of Scheme, however.  Even implementations
%that support the \sharpsign\backwhack{} notation for input do not have to
%support it for output.

\vest Some of the procedures that operate on characters ignore the
difference between upper case and lower case.  The procedures that
ignore case have \hbox{``{\tt -ci}''} (for ``case
insensitive'') embedded in their names.


\begin{entry}{%
\proto{char?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a character, otherwise returns \schfalse.

\end{entry}


\begin{entry}{%
\proto{char=?}{ \vari{char} \varii{char}}{procedure}
\proto{char<?}{ \vari{char} \varii{char}}{procedure}
\proto{char>?}{ \vari{char} \varii{char}}{procedure}
\proto{char<=?}{ \vari{char} \varii{char}}{procedure}
\proto{char>=?}{ \vari{char} \varii{char}}{procedure}}

\label{characterequality}
\nodomain{Both \vari{char} and \varii{char} must be characters.}
These procedures impose a total ordering on the set of characters which
is the same as the Unicode code point ordering.  This is true independent
of whether the implementation uses the Unicode representation internally.

Some implementations may generalize these procedures to take more than
two arguments, as with the corresponding numerical predicates.

\end{entry}


\begin{entry}{%
\proto{char-ci=?}{ \vari{char} \varii{char}}{unicode module procedure}
\proto{char-ci<?}{ \vari{char} \varii{char}}{unicode module procedure}
\proto{char-ci>?}{ \vari{char} \varii{char}}{unicode module procedure}
\proto{char-ci<=?}{ \vari{char} \varii{char}}{unicode module procedure}
\proto{char-ci>=?}{ \vari{char} \varii{char}}{unicode module procedure}}

\nodomain{Both \vari{char} and \varii{char} must be characters.}
These procedures are similar to {\cf char=?}\ et cetera, but they treat
upper case and lower case letters as the same.  For example, {\cf
(char-ci=?\ \#\backwhack{}A \#\backwhack{}a)} returns \schtrue.

Specifically, these procedures behave as if {\cf char-foldcase} were
applied to their arguments before comparing them.

Some implementations may generalize these procedures to take more than
two arguments, as with the corresponding numerical predicates.

\end{entry}


\begin{entry}{%
\proto{char-alphabetic?}{ char}{procedure}
\proto{char-numeric?}{ char}{procedure}
\proto{char-whitespace?}{ char}{procedure}
\proto{char-upper-case?}{ letter}{procedure}
\proto{char-lower-case?}{ letter}{procedure}}

These procedures return \schtrue{} if their arguments are alphabetic,
numeric, whitespace, upper case, or lower case characters, respectively,
otherwise they return \schfalse.  

Specifically, they must return \schtrue{} when applied to characters with
the Unicode properties Alphabetic, Numeric, White\_Space, Uppercase, and
Lowercase respectively, and \schfalse{} when applied to any other Unicode
characters.  Note that many Unicode characters are alphabetic but neither
upper nor lower case.

\end{entry}


%%R4%%\begin{entry}{%
%\proto{char-upper-case?}{ letter}{procedure}
%\proto{char-lower-case?}{ letter}{procedure}}
%
%\domain{\var{Letter} must be an alphabetic character.}
%These procedures return \schtrue{} if their arguments are upper case or
%lower case characters, respectively, otherwise they return \schfalse.
%\end{entry}


\begin{entry}{%
\proto{char->integer}{ char}{procedure}
\proto{integer->char}{ \vr{n}}{procedure}}

Given a Unicode character, 
{\cf char\coerce{}integer} returns an exact integer 
between 0 and {\tt \#xD7FF} or 
between {\tt \#xE000} and {\tt \#x10FFFF} 
which is equal to the Unicode code point of that character.
Given a non-Unicode character, 
it returns an exact integer greater than {\tt \#x10FFFF}.  
This is true independent of whether the implementation uses
the Unicode representation internally.

Given an exact integer that is the value returned by
a character when {\cf char\coerce{}integer} is applied to it, {\cf integer\coerce{}char}
returns that character.
%What follows is still true, but no longer necessary:
%These procedures implement order-preserving isomorphism
%between the set of characters under the \ide{char<=?}\ ordering and some
%subset of the integers under the {\cf <=}\ ordering.  That is, if
%
%\begin{scheme}
%(char<=? \vr{a} \vr{b}) \evalsto \schtrue  {\rm{}and}  %
%(<= \vr{x} \vr{y}) \evalsto \schtrue%
%\end{scheme}
%
%\noindent and \vr{x} and \vr{y} are in the domain of
%{\cf integer\coerce{}char}, then
%
%\begin{scheme}
%(<= (char\coerce{}integer \vr{a})
%    (char\coerce{}integer \vr{b}))         \ev  \schtrue
%
%(char<=? (integer\coerce{}char \vr{x})
%         (integer\coerce{}char \vr{y}))     \ev  \schtrue%
%\end{scheme}
%
\end{entry}


\begin{entry}{%
\proto{char-upcase}{ char}{unicode module procedure}
\proto{char-downcase}{ char}{unicode module procedure}
\proto{char-foldcase}{ char}{unicode module procedure}}

\nodomain{\var{Char} must be a character.}

The {\cf char-upcase} procedure, given an argument that forms the
lowercase part of a Unicode casing pair, returns the uppercase member
of the pair, provided that both characters are supported by the Scheme
implementation.  Note that Turkic casing pairs are not used.  If the
argument is not the lowercase part of such a pair, it is returned.

The {\cf char-downcase} procedure, given an argument that forms the
uppercase part of a Unicode casing pair, returns the lowercase member
of the pair, provided that both characters are supported by the Scheme
implementation.  Note that Turkic casing pairs are not used.  If the
argument is not the uppercase part of such a pair, it is returned.

The {\cf char-foldcase} procedure applies the Unicode simple
case-folding algorithm to its argument and returns the result.  Note that
Turkic-specific folding is not used.  If the argument is an uppercase
letter, the result will be a lowercase letter.

Note that many Unicode lowercase characters do not have uppercase
equivalents.

\end{entry}


\subsection{Strings}
\label{stringsection}

Strings are sequences of characters.  
Implementations may support characters that they do not allow to appear
in strings.
%In some implementations of Scheme
%they are immutable; other implementations provide destructive procedures
%such as {\cf string-set!}\ that alter string objects.
\vest Strings are written as sequences of characters enclosed within doublequotes
({\cf "}).  Within a string literal, various escape
sequences\mainindex{escape sequence} represent characters other than
themselves.  Escape sequences always start with a backslash (\backwhack{}):

\begin{itemize}
\item{\cf\backwhack{}a} : alarm, U+0007
\item{\cf\backwhack{}b} : backspace, U+0008 
\item{\cf\backwhack{}t} : character tabulation, U+0009 
\item{\cf\backwhack{}n} : linefeed, U+000A 
\item{\cf\backwhack{}r} : return, U+000D 
\item{\cf\backwhack{}}\verb|"| : doublequote, U+0022 
\item{\cf\backwhack{}\backwhack{}} : backslash, U+005C 
\item{\cf\backwhack{}x\meta{hex scalar value};} : specified character (note the
  terminating semi-colon).
\end{itemize}

The result is unspecified if any other character in a string occurs
after a backslash.

\vest A string constant may continue from one line to the next, which
has the same effect as inserting a {\cf\backwhack{}n} character into the string.
% this is
%usually a bad idea because 
%the exact effect may vary from one computer
%system to another.

Example:

\begin{scheme}
"The word \backwhack{}"recursion\backwhack{}" has many meanings."%
\end{scheme}

\vest The {\em length} of a string is the number of characters that it
contains.  This number is an exact, non-negative integer that is fixed when the
string is created.  The \defining{valid indexes} of a string are the
exact non-negative integers less than the length of the string.  The first
character of a string has index 0, the second has index 1, and so on.

\vest In phrases such as ``the characters of \var{string} beginning with
index \var{start} and ending with index \var{end},'' it is understood
that the index \var{start} is inclusive and the index \var{end} is
exclusive.  Thus if \var{start} and \var{end} are the same index, a null
substring is referred to, and if \var{start} is zero and \var{end} is
the length of \var{string}, then the entire string is referred to.

\vest Some of the procedures that operate on strings ignore the
difference between upper and lower case.  The versions that ignore case
have \hbox{``{\cf -ci}''} (for ``case insensitive'') embedded in their
names.


\begin{entry}{%
\proto{string?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a string, otherwise returns \schfalse.
\end{entry}


\begin{entry}{%
\proto{make-string}{ \vr{k}}{procedure}
\rproto{make-string}{ \vr{k} char}{procedure}}

%\domain{\vr{k} must be a non-negative integer, and \var{char} must be
%a character.}  
{\cf Make-string} returns a newly allocated string of
length \vr{k}.  If \var{char} is given, then all elements of the string
are initialized to \var{char}, otherwise the contents of the
string are unspecified.

\end{entry}

\begin{entry}{%
\proto{string}{ char \dotsfoo}{procedure}}

Returns a newly allocated string composed of the arguments.

\end{entry}

\begin{entry}{%
\proto{string-length}{ string}{procedure}}

Returns the number of characters in the given \var{string}.
\end{entry}


\begin{entry}{%
\proto{string-ref}{ string \vr{k}}{procedure}}

\domain{\vr{k} must be a valid index of \var{string}.}
{\cf String-ref} returns character \vr{k} of \var{string} using zero-origin indexing.
\end{entry}


\begin{entry}{%
\proto{string-set!}{ string k char}{procedure}}

\domain{%\var{String} must be a string, 
\vr{k} must be a valid index of \var{string}%, and \var{char} must be a character
.}
{\cf String-set!} stores \var{char} in element \vr{k} of \var{string}
and returns an unspecified value.  % <!>

\begin{scheme}
(define (f) (make-string 3 \sharpsign\backwhack{}*))
(define (g) "***")
(string-set! (f) 0 \sharpsign\backwhack{}?)  \ev  \unspecified
(string-set! (g) 0 \sharpsign\backwhack{}?)  \ev  \scherror
(string-set! (symbol->string 'immutable)
             0
             \sharpsign\backwhack{}?)  \ev  \scherror%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{string=?}{ \vari{string} \varii{string}}{procedure}}

Returns \schtrue{} if the two strings are the same length and contain
exactly the same characters in the same positions, otherwise returns
\schfalse.

\end{entry}

\begin{entry}{%
\proto{string-ci=?}{ \vari{string} \varii{string}}{unicode module procedure}}

Returns \schtrue{} if, after case-folding, the two strings are the same
length and contain the same characters in the same positions, otherwise
returns \schfalse.  Specifically, these procedures behave as if 
{\cf string-foldcase} were applied to their arguments before comparing them.

\end{entry}


\begin{entry}{%
\proto{string-ni=?}{ \vari{string} \varii{string}}{unicode module procedure}}

Returns \schtrue{} if, after an implementation-defined normalization,
the two strings are the same length and contain the same characters in
the same positions, otherwise returns \schfalse.  The intent is to
provide a means of comparing strings that should be considered
equivalent in some situations but may be represented by a different
sequence of characters.  Specifically, an implementation which
supports Unicode should consider using Unicode normalization NFC or
NFD as specified by Unicode TR\#15.  Implementations which only
support ASCII or some other character set which provides no ambiguous
representations of character sequences may define the normalization to
be the identity operation, in which case {\cf string-ni=?}\ is
equivalent to {\cf string=?}.

\end{entry}


\begin{entry}{%
\proto{string<?}{ \vari{string} \varii{string}}{procedure}
\proto{string>?}{ \vari{string} \varii{string}}{procedure}
\proto{string<=?}{ \vari{string} \varii{string}}{procedure}
\proto{string>=?}{ \vari{string} \varii{string}}{procedure}
\proto{string-ci<?}{ \vari{string} \varii{string}}{unicode module procedure}
\proto{string-ci>?}{ \vari{string} \varii{string}}{unicode module procedure}
\proto{string-ci<=?}{ \vari{string} \varii{string}}{unicode module procedure}
\proto{string-ci>=?}{ \vari{string} \varii{string}}{unicode module procedure}
\proto{string-ni<?}{ \vari{string} \varii{string}}{unicode module procedure}
\proto{string-ni>?}{ \vari{string} \varii{string}}{unicode module procedure}
\proto{string-ni<=?}{ \vari{string} \varii{string}}{unicode module procedure}
\proto{string-ni>=?}{ \vari{string} \varii{string}}{unicode module procedure}}

These procedures compare strings in an implementation-defined way.
One approach is to make them the lexicographic extensions to strings of
the corresponding orderings on characters.  In that case, {\cf string<?}\
would be the lexicographic ordering on strings induced by the ordering
{\cf char<?}\ on characters, and if the two strings differ in length but
are the same up to the length of the shorter string, the shorter string
would be considered to be lexicographically less than the longer string.
However, it is also permitted to use the natural ordering imposed by the
internal representation of strings, or a more complex locale-specific
ordering.

In all cases, a pair of strings must satisfy exactly one of
{\cf string<?}, {\cf string=?}, and {\cf string>?}, and must satisfy
{\cf string<=?} if and only if they do not satisfy {\cf string>?} and
{\cf string>=?} if and only if they do not satisfy {\cf string<?}.

The \hbox{``{\tt -ci}''} procedures behave as if they applied
{\cf string-foldcase} to their arguments before invoking the corresponding
procedures without  \hbox{``{\tt -ci}''}.

The \hbox{``{\tt -ni}''} procedures behave as if they applied the
implementation-defined normalization used by {\cf string-ni=?}
to their arguments before
invoking the corresponding procedures without \hbox{``{\tt -ni}''}.

Implementations may generalize these and the {\cf string=?},\ {\cf
  string-ci=?}, and {\cf string-ni=?}\ procedures to take more than
two arguments, as with the corresponding numerical predicates.

\end{entry}

\begin{entry}{%
\proto{string-upcase}{ string}{unicode module procedure}
\proto{string-downcase}{ string}{unicode module procedure}
\proto{string-foldcase}{ string}{unicode module procedure}}

\nodomain{\var{String} must be a string.}

These procedures apply the Unicode full string uppercasing, lowercasing,
and case-folding algorithms to their arguments and return the result.
Note that Turkic-specific mappings and foldings are not used.  
The result may differ in length from the argument.  What is more, a
few characters have case-mappings that depend on the surrounding context.
For example, Greek capital sigma normally lowercases to Greek small sigma,
but at the end of a word it downcases to Greek small final sigma instead.

\end{entry}


\begin{entry}{%
\proto{substring}{ string start end}{procedure}}

\domain{\var{String} must be a string, and \var{start} and \var{end}
must be exact integers satisfying
$$0 \leq \var{start} \leq \var{end} \leq \hbox{\tt(string-length \var{string})\rm.}$$}
{\cf Substring} returns a newly allocated string formed from the characters of
\var{string} beginning with index \var{start} (inclusive) and ending with index
\var{end} (exclusive).
\end{entry}


\begin{entry}{%
\proto{string-append}{ \var{string} \dotsfoo}{procedure}}

Returns a newly allocated string whose characters form the concatenation of the
given strings.

\end{entry}


\begin{entry}{%
\proto{string->list}{ string}{procedure}
\proto{list->string}{ list}{procedure}}

{\cf String\coerce{}list} returns a newly allocated list of the
characters that make up the given string.  {\cf List\coerce{}string}
returns a newly allocated string formed from the characters in the list
\var{list}, which must be a list of characters. {\cf String\coerce{}list}
and {\cf list\coerce{}string} are
inverses so far as {\cf equal?}\ is concerned.  
%Implementations that provide
%destructive operations on strings should ensure that the result of
%{\cf list\coerce{}string} is newly allocated.

\end{entry}


\begin{entry}{%
\proto{string-copy}{ string}{procedure}}

Returns a newly allocated copy of the given \var{string}.

\end{entry}


\begin{entry}{%
\proto{string-fill!}{ string char}{procedure}}

Stores \var{char} in every element of the given \var{string} and returns an
unspecified value.  % <!>

\end{entry}


\subsection{Vectors}
\label{vectorsection}

Vectors are heterogenous structures whose elements are indexed
by integers.  A vector typically occupies less space than a list
of the same length, and the average time required to access a randomly
chosen element is typically less for the vector than for the list.

\vest The {\em length} of a vector is the number of elements that it
contains.  This number is a non-negative integer that is fixed when the
vector is created.  The {\em valid indexes}\index{valid indexes} of a
vector are the exact non-negative integers less than the length of the
vector.  The first element in a vector is indexed by zero, and the last
element is indexed by one less than the length of the vector.

Vectors are written using the notation {\tt\#(\var{obj} \dotsfoo)}.
For example, a vector of length 3 containing the number zero in element
0, the list {\cf(2 2 2 2)} in element 1, and the string {\cf "Anna"} in
element 2 can be written as following:

\begin{scheme}
\#(0 (2 2 2 2) "Anna")%
\end{scheme}

Note that this is the external representation of a vector, not an
expression evaluating to a vector.  Like list constants, vector
constants must be quoted:

\begin{scheme}
'\#(0 (2 2 2 2) "Anna")  \lev  \#(0 (2 2 2 2) "Anna")%
\end{scheme}

\todo{Pitman sez: The visual similarity to lists is bound to be confusing
to some.  Elaborate on the distinction.}


\begin{entry}{%
\proto{vector?}{ obj}{procedure}}
 
Returns \schtrue{} if \var{obj} is a vector, otherwise returns \schfalse.
\end{entry}


\begin{entry}{%
\proto{make-vector}{ k}{procedure}
\rproto{make-vector}{ k fill}{procedure}}

Returns a newly allocated vector of \var{k} elements.  If a second
argument is given, then each element is initialized to \var{fill}.
Otherwise the initial contents of each element is unspecified.

\end{entry}


\begin{entry}{%
\proto{vector}{ obj \dotsfoo}{procedure}}

Returns a newly allocated vector whose elements contain the given
arguments.  Analogous to {\cf list}.

\begin{scheme}
(vector 'a 'b 'c)               \ev  \#(a b c)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector-length}{ vector}{procedure}}

Returns the number of elements in \var{vector} as an exact integer.
\end{entry}


\begin{entry}{%
\proto{vector-ref}{ vector k}{procedure}}

\domain{\vr{k} must be a valid index of \var{vector}.}
{\cf Vector-ref} returns the contents of element \vr{k} of
\var{vector}.

\begin{scheme}
(vector-ref '\#(1 1 2 3 5 8 13 21)
            5)  \lev  8
(vector-ref '\#(1 1 2 3 5 8 13 21)
            (let ((i (round (* 2 (acos -1)))))
              (if (inexact? i)
                  (inexact->exact i)
                  i))) \lev 13%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector-set!}{ vector k obj}{procedure}}

\domain{\vr{k} must be a valid index of \var{vector}.}
{\cf Vector-set!} stores \var{obj} in element \vr{k} of \var{vector}.
The value returned by {\cf vector-set!}\ is unspecified.  % <!>

\begin{scheme}
(let ((vec (vector 0 '(2 2 2 2) "Anna")))
  (vector-set! vec 1 '("Sue" "Sue"))
  vec)      \lev  \#(0 ("Sue" "Sue") "Anna")

(vector-set! '\#(0 1 2) 1 "doe")  \lev  \scherror  ; constant vector%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector->list}{ vector}{procedure}
\proto{list->vector}{ list}{procedure}}

{\cf Vector->list} returns a newly allocated list of the objects contained
in the elements of \var{vector}.  {\cf List->vector} returns a newly
created vector initialized to the elements of the list \var{list}.

\begin{scheme}
(vector->list '\#(dah dah didah))  \lev  (dah dah didah)
(list->vector '(dididit dah))   \lev  \#(dididit dah)%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{vector->string}{ string}{procedure}
\proto{string->vector}{ vector}{procedure}}

{\cf Vector->string} returns a newly allocated string of the objects contained
in the elements of \var{vector}, which must be characters.
{\cf String->vector} returns a newly
created vector initialized to the elements of the string \var{string}.

\end{entry}

\begin{entry}{%
\proto{vector-copy}{ vector}{procedure}}

Returns a newly allocated copy of the given \var{vector}.

\end{entry}


\begin{entry}{%
\proto{vector-fill!}{ vector fill}{procedure}}

Stores \var{fill} in every element of \var{vector}.
The value returned by {\cf vector-fill!}\ is unspecified.  % <!>

\end{entry}


\subsection{Bytevectors}
\label{bytevectorsection}

Bytevectors are a disjoint type for representing blocks of binary data.
Conceptually, bytevectors can be thought of as homogenous vectors of 8-bit
bytes, but they typically occupy less space than a vector.
A byte is an exact integer in the range $[0..255]$.

\vest The {\em length} of a bytevector is the number of elements that it
contains.  This number is a non-negative integer that is fixed when
the bytevector is created.  The {\em valid indexes}\index{valid indexes} of
a bytevector are the exact non-negative integers less than the length of the
bytevector, starting at index zero as with vectors.

\begin{entry}{%
\proto{bytevector?}{ obj}{procedure}}

Returns \schtrue{} iff \var{obj} is a bytevector.
\end{entry}

\begin{entry}{%
\proto{make-bytevector}{ k}{procedure}
\rproto{make-bytevector}{ k byte}{procedure}}

{\cf Make-bytevector} returns a newly allocated bytevector of
length \vr{k}.  If \var{byte} is given, then all elements of the bytevector
are initialized to \var{byte}, otherwise the contents of each
element are unspecified.
\end{entry}

\begin{entry}{%
\proto{bytevector-length}{ bytevector}{procedure}}

Returns the length of \var{bytevector} in bytes as an exact integer.
\end{entry}

\begin{entry}{%
\proto{bytevector-u8-ref}{ bytevector k}{procedure}}

Returns the \var{k}th byte of \var{bytevector}.
\end{entry}

\begin{entry}{%
\proto{bytevector-u8-set!}{ bytevector k byte}{procedure}}

Stores \var{byte} as the \var{k}th byte of \var{bytevector}.
The value returned by
{\cf bytevector-u8-set!} is unspecified.
\end{entry}

\begin{entry}{%
\proto{bytevector-copy}{ bytevector}{procedure}}

Returns a newly allocated bytevector containing the same bytes as
\var{bytevector}.
\end{entry}

\begin{entry}{%
\proto{bytevector-copy!}{ from to}{procedure}}

Copy the bytes of bytevector \var{from} to bytevector \var{to}, which must not be
shorter.  The value returned by {\cf bytevector-copy!} is unspecified.
\end{entry}

\begin{entry}{%
\proto{partial-bytevector}{ bytevector start end}{procedure}}

Returns a newly allocated bytevector containing the bytes in \var{bytevector}
between \var{start} (inclusive) and \var{end}
(exclusive).
\end{entry}

\begin{entry}{%
\proto{partial-bytevector-copy!}{ from start end to at}{procedure}}

Copy the bytes of bytevector \var{from} between \var{start} and \var{end}
to bytevector \var{to}, starting at \var{at}.  The order in which bytes are
copied is unspecified, except that if the source and destination overlap,
copying takes place as if the source is first copied into a temporary
bytevector and then into the destination.  This can be achieved without
allocating storage by making sure to copy in the correct direction in
such circumstances.

The inequality
\texttt{({\cf >=} ({\cf -} ({\cf bytevector-length} \var{to}) \var{at}) ({\cf -} \var{end} \var{start}))}
must be true.  The value returned by {\cf partial-bytevector-copy!} is unspecified.
\end{entry}


\section{Control features}
\label{proceduresection}
 
% Intro flushed; not very a propos any more.
% Procedures should be discussed somewhere, however.

This chapter describes various primitive procedures which control the
flow of program execution in special ways.
The {\cf procedure?}\ predicate is also described here.

\todo{{\tt Procedure?} doesn't belong in a section with the name
``control features.''  What to do?}

\begin{entry}{%
\proto{procedure?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a procedure, otherwise returns \schfalse.

\begin{scheme}
(procedure? car)            \ev  \schtrue
(procedure? 'car)           \ev  \schfalse
(procedure? (lambda (x) (* x x)))   
                            \ev  \schtrue
(procedure? '(lambda (x) (* x x)))  
                            \ev  \schfalse
(call-with-current-continuation procedure?)
                            \ev  \schtrue%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{apply}{ proc \vari{arg} $\ldots$ args}{procedure}}

\domain{\var{Proc} must be a procedure and \var{args} must be a list.}
Calls \var{proc} with the elements of the list
{\cf(append (list \vari{arg} \dotsfoo) \var{args})} as the actual
arguments.

\begin{scheme}
(apply + (list 3 4))              \ev  7

(define compose
  (lambda (f g)
    (lambda args
      (f (apply g args)))))

((compose sqrt *) 12 75)              \ev  30%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{map}{ proc \vari{list} \varii{list} \dotsfoo}{procedure}}

\domain{The \var{list}s must be lists, and \var{proc} must be a
procedure taking as many arguments as there are {\it list}s
and returning a single value.  If more
than one \var{list} is given and not all lists have the same length,
{\cf map} terminates when the shortest list runs out.}
{\cf Map} applies \var{proc} element-wise to the elements of the
\var{list}s and returns a list of the results, in order.  It is an
error for \var{proc} to mutate any of the lists.
The dynamic order in which \var{proc} is applied to the elements of the
\var{list}s is unspecified.  If multiple returns occur from {\cf map},
the values returned by earlier returns are not mutated.

\begin{scheme}
(map cadr '((a b) (d e) (g h)))   \lev  (b e h)

(map (lambda (n) (expt n n))
     '(1 2 3 4 5))                \lev  (1 4 27 256 3125)

(map + '(1 2 3) '(4 5 6))         \ev  (5 7 9)

(let ((count 0))
  (map (lambda (ignored)
         (set! count (+ count 1))
         count)
       '(a b)))                 \ev  (1 2) \var{or} (2 1)
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{string-map}{ proc \vari{string} \varii{string} \dotsfoo}{procedure}}

\domain{The \var{string}s must be strings, and \var{proc} must be a
procedure taking as many arguments as there are {\it string}s
and returning a single value.  If more
than one \var{string} is given and not all strings have the same length,
{\cf string-map} terminates when the shortest list runs out.}
{\cf String-map} applies \var{proc} element-wise to the elements of the
\var{string}s and returns a string of the results, in order.
The dynamic order in which \var{proc} is applied to the elements of the
\var{string}s is unspecified.
If multiple returns occur from {\cf string-map},
the values returned by earlier returns are not mutated.

\begin{scheme}
(string-map char-foldcase "AbdEgH") \lev  "abdegh"

(string-map
 (lambda (c)
   (integer->char (+ 1 (char->integer c))))
 "HAL")                \lev  "IBM"

(string-map
 (lambda (c k)
   (if (eqv? k \sharpsign\backwhack{}u)
       (char-upcase c)
       (char-downcase c)))
 "studlycaps"
 "ululululul")   \lev   "StUdLyCaPs"
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{vector-map}{ proc \vari{vector} \varii{vector} \dotsfoo}{procedure}}

\domain{The \var{vector}s must be vectors, and \var{proc} must be a
procedure taking as many arguments as there are {\it vector}s
and returning a single value.  If more
than one \var{vector} is given and not all vectors have the same length,
{\cf vector-map} terminates when the shortest list runs out.}
{\cf Vector-map} applies \var{proc} element-wise to the elements of the
\var{vector}s and returns a vector of the results, in order.
The dynamic order in which \var{proc} is applied to the elements of the
\var{vector}s is unspecified.
If multiple returns occur from {\cf vector-map},
the values returned by earlier returns are not mutated.

\begin{scheme}
(vector-map cadr '\#((a b) (d e) (g h)))   \lev  \#(b e h)

(vector-map (lambda (n) (expt n n))
            '\#(1 2 3 4 5))                \lev  \#(1 4 27 256 3125)

(vector-map + '\#(1 2 3) '\#(4 5 6))       \ev  \#(5 7 9)

(let ((count 0))
  (vector-map
   (lambda (ignored)
     (set! count (+ count 1))
     count)
   '\#(a b)))                     \ev  \#(1 2) \var{or} \#(2 1)
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{for-each}{ proc \vari{list} \varii{list} \dotsfoo}{procedure}}

The arguments to {\cf for-each} are like the arguments to {\cf map}, but
{\cf for-each} calls \var{proc} for its side effects rather than for its
values.  Unlike {\cf map}, {\cf for-each} is guaranteed to call \var{proc} on
the elements of the \var{list}s in order from the first element(s) to the
last, and the value returned by {\cf for-each} is unspecified.
It is an error for \var{proc} to mutate any of the lists.
If more than one \var{list} is given and not all lists have the same length,
{\cf for-each} terminates when the shortest list runs out.

\begin{scheme}
(let ((v (make-vector 5)))
  (for-each (lambda (i)
              (vector-set! v i (* i i)))
            '(0 1 2 3 4))
  v)                                \ev  \#(0 1 4 9 16)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{string-for-each}{ proc \vari{string} \varii{string} \dotsfoo}{procedure}}

The arguments to {\cf string-for-each} are like the arguments to {\cf
string-map}, but {\cf string-for-each} calls \var{proc} for its side
effects rather than for its values.  Unlike {\cf string-map}, {\cf
string-for-each} is guaranteed to call \var{proc} on the elements of
the \var{list}s in order from the first element(s) to the last, and the
value returned by {\cf string-for-each} is unspecified.
If more than one \var{string} is given and not all strings have the same length,
{\cf string-for-each} terminates when the shortest string runs out.

\begin{scheme}
(let ((v '()))
  (string-for-each
   (lambda (c) (set! v (cons (char->integer c) v))
   "abcde")
  v)                                \ev  (101 100 99 98 97)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{vector-for-each}{ proc \vari{vector} \varii{vector} \dotsfoo}{procedure}}

The arguments to {\cf vector-for-each} are like the arguments to {\cf
vector-map}, but {\cf vector-for-each} calls \var{proc} for its side
effects rather than for its values.  Unlike {\cf vector-map}, {\cf
vector-for-each} is guaranteed to call \var{proc} on the elements of
the \var{vector}s in order from the first element(s) to the last, and
the value returned by {\cf vector-for-each} is unspecified.
If more than one \var{vector} is given and not all vectors have the same length,
{\cf vector-for-each} terminates when the shortest vector runs out.

\begin{scheme}
(let ((v (make-list 5)))
  (vector-for-each
   (lambda (i) (list-set! v i (* i i)))
   '\#(0 1 2 3 4))
  v)                                \ev  (0 1 4 9 16)%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{force}{ promise}{lazy module procedure}}

Forces the value of \var{promise} (see \ide{delay},
section~\ref{delay}).\index{promise}  If no value has been computed for
the promise, then a value is computed and returned.  The value of the
promise is cached (or ``memoized'') so that if it is forced a second
time, the previously computed value is returned.
% without any recomputation.
% [As pointed out by Marc Feeley, the "without any recomputation"
% isn't necessarily true. --Will]

\begin{scheme}
(force (delay (+ 1 2)))   \ev  3
(let ((p (delay (+ 1 2))))
  (list (force p) (force p)))  
                               \ev  (3 3)

(define a-stream
  (letrec ((next
            (lambda (n)
              (cons n (delay (next (+ n 1)))))))
    (next 0)))
(define head car)
(define tail
  (lambda (stream) (force (cdr stream))))

(head (tail (tail a-stream)))  
                               \ev  2%
\end{scheme}

{\cf Force} and {\cf delay} are mainly intended for programs written in
functional style.  The following examples should not be considered to
illustrate good programming style, but they illustrate the property that
only one value is computed for a promise, no matter how many times it is
forced.
% the value of a promise is computed at most once.
% [As pointed out by Marc Feeley, it may be computed more than once,
% but as I observed we can at least insist that only one value be
% used! -- Will]

\begin{scheme}
(define count 0)
(define p
  (delay (begin (set! count (+ count 1))
                (if (> count x)
                    count
                    (force p)))))
(define x 5)
p                     \ev  {\it{}a promise}
(force p)             \ev  6
p                     \ev  {\it{}a promise, still}
(begin (set! x 10)
       (force p))     \ev  6%
\end{scheme}

Here is a possible implementation of {\cf delay} and {\cf force}.
Promises are implemented here as procedures of no arguments,
and {\cf force} simply calls its argument:

\begin{scheme}
(define force
  (lambda (object)
    (object)))%
\end{scheme}

We define the expression

\begin{scheme}
(delay \hyper{expression})%
\end{scheme}

to have the same meaning as the procedure call

\begin{scheme}
(make-promise (lambda () \hyper{expression}))\rm
\end{scheme}

as follows

\begin{scheme}
(define-syntax delay
  (syntax-rules ()
    ((delay expression)
     (make-promise (lambda () expression))))),%
\end{scheme}

where {\cf make-promise} is defined as follows:

% \begin{scheme}
% (define make-promise
%   (lambda (proc)
%     (let ((already-run? \schfalse) (result \schfalse))
%       (lambda ()
%         (cond ((not already-run?)
%                (set! result (proc))
%                (set! already-run? \schtrue)))
%         result))))%
% \end{scheme}

\begin{scheme}
(define make-promise
  (lambda (proc)
    (let ((result-ready? \schfalse)
          (result \schfalse))
      (lambda ()
        (if result-ready?
            result
            (let ((x (proc)))
              (if result-ready?
                  result
                  (begin (set! result-ready? \schtrue)
                         (set! result x)
                         result))))))))%
\end{scheme}

\begin{rationale}
A promise may refer to its own value, as in the last example above.
Forcing such a promise may cause the promise to be forced a second time
before the value of the first force has been computed.
This complicates the definition of {\cf make-promise}.
\end{rationale}

Various extensions to this semantics of {\cf delay} and {\cf force}
are supported in some implementations:

\begin{itemize}
\item Calling {\cf force} on an object that is not a promise may simply
return the object.

\item It may be the case that there is no means by which a promise can be
operationally distinguished from its forced value.  That is, expressions
like the following may evaluate to either \schtrue{} or to \schfalse{},
depending on the implementation:

\begin{scheme}
(eqv? (delay 1) 1)          \ev  \unspecified
(pair? (delay (cons 1 2)))  \ev  \unspecified%
\end{scheme}

\item Some implementations may implement ``implicit forcing,'' where
the value of a promise is forced by primitive procedures like \cf{cdr}
and \cf{+}:

\begin{scheme}
(+ (delay (* 3 7)) 13)  \ev  34%
\end{scheme}
\end{itemize}
\end{entry}

\begin{entry}{%
\proto{call-with-current-continuation}{ proc}{procedure}
\proto{call/cc}{ proc}{procedure}}

\label{continuations} \domain{\var{Proc} must be a procedure of one
argument.} The procedure {\cf call-with-current-continuation} (or its
equivalent abbreviation {\cf call/cc}) packages
up the current continuation (see the rationale below) as an ``escape
procedure''\mainindex{escape procedure} and passes it as an argument to
\var{proc}.  The escape procedure is a Scheme procedure that, if it is
later called, will abandon whatever continuation is in effect at that later
time and will instead use the continuation that was in effect
when the escape procedure was created.  Calling the escape procedure
may cause the invocation of \var{before} and \var{after} thunks installed using
\ide{dynamic-wind}.

The escape procedure accepts the same number of arguments as the continuation to
the original call to \callcc.
Except for continuations created by the {\cf call-with-values}
procedure, all continuations take exactly one value.  The
effect of passing no value or more than one value to continuations
that were not created by {\tt call-with-values} is unspecified.

\vest The escape procedure that is passed to \var{proc} has
unlimited extent just like any other procedure in Scheme.  It may be stored
in variables or data structures and may be called as many times as desired.

\vest The following examples show only the most common ways in which
{\cf call-with-current-continuation} is used.  If all real uses were as
simple as these examples, there would be no need for a procedure with
the power of {\cf call-with-current-continuation}.

\begin{scheme}
(call-with-current-continuation
  (lambda (exit)
    (for-each (lambda (x)
                (if (negative? x)
                    (exit x)))
              '(54 0 37 -3 245 19))
    \schtrue))                        \ev  -3

(define list-length
  (lambda (obj)
    (call-with-current-continuation
      (lambda (return)
        (letrec ((r
                  (lambda (obj)
                    (cond ((null? obj) 0)
                          ((pair? obj)
                           (+ (r (cdr obj)) 1))
                          (else (return \schfalse))))))
          (r obj))))))

(list-length '(1 2 3 4))            \ev  4

(list-length '(a b . c))            \ev  \schfalse%
\end{scheme}

\begin{rationale}

\vest A common use of {\cf call-with-current-continuation} is for
structured, non-local exits from loops or procedure bodies, but in fact
{\cf call-with-current-continuation} is extremely useful for implementing a
wide variety of advanced control structures.

\vest Whenever a Scheme expression is evaluated there is a
\defining{continuation} wanting the result of the expression.  The continuation
represents an entire (default) future for the computation.  If the expression is
evaluated at top level, for example, then the continuation might take the
result, print it on the screen, prompt for the next input, evaluate it, and
so on forever.  Most of the time the continuation includes actions
specified by user code, as in a continuation that will take the result,
multiply it by the value stored in a local variable, add seven, and give
the answer to the top level continuation to be printed.  Normally these
ubiquitous continuations are hidden behind the scenes and programmers do not
think much about them.  On rare occasions, however, a programmer may
need to deal with continuations explicitly.
{\cf Call-with-current-continuation} allows Scheme programmers to do
that by creating a procedure that acts just like the current
continuation.

\vest Most programming languages incorporate one or more special-purpose
escape constructs with names like {\tt exit}, \hbox{{\cf return}}, or
even {\tt goto}.  In 1965, however, Peter Landin~\cite{Landin65}
invented a general purpose escape operator called the J-operator.  John
Reynolds~\cite{Reynolds72} described a simpler but equally powerful
construct in 1972.  The {\cf catch} special form described by Sussman
and Steele in the 1975 report on Scheme is exactly the same as
Reynolds's construct, though its name came from a less general construct
in MacLisp.  Several Scheme implementors noticed that the full power of the
\ide{catch} construct could be provided by a procedure instead of by a
special syntactic construct, and the name
{\cf call-with-current-continuation} was coined in 1982.  This name is
descriptive, but opinions differ on the merits of such a long name, and
some people use the name \ide{call/cc} instead.
\end{rationale}

\end{entry}

\begin{entry}{%
\proto{values}{ obj $\ldots$}{multiple-values module procedure}}

Delivers all of its arguments to its continuation.
Except for continuations created by the \ide{call-with-values}
procedure, all continuations take exactly one value.
{\tt Values} might be defined as follows:
\begin{scheme}
(define (values . things)
  (call-with-current-continuation 
    (lambda (cont) (apply cont things))))
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{call-with-values}{ producer consumer}{multiple-values module procedure}}

Calls its \var{producer} argument with no values and
a continuation that, when passed some values, calls the
\var{consumer} procedure with those values as arguments.
The continuation for the call to \var{consumer} is the
continuation of the call to {\tt call-with-values}.

\begin{scheme}
(call-with-values (lambda () (values 4 5))
                  (lambda (a b) b))
                                                   \ev  5

(call-with-values * -)                             \ev  -1
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{dynamic-wind}{ before thunk after}{procedure}}

Calls \var{thunk} without arguments, returning the result(s) of this call.
\var{Before} and \var{after} are called, also without arguments, as required
by the following rules (note that in the absence of calls to continuations
captured using \ide{call-with-current-continuation} the three arguments are
called once each, in order).  \var{Before} is called whenever execution
enters the dynamic extent of the call to \var{thunk} and \var{after} is called
whenever it exits that dynamic extent.  The dynamic extent of a procedure
call is the period between when the call is initiated and when it
returns.  \var{Before} and \var{after} are excluded from the dynamic extent.
In Scheme, because of {\cf call-with-current-continuation}, the
dynamic extent of a call may not be a single, connected time period.
It is defined as follows:
\begin{itemize}
\item The dynamic extent is entered when execution of the body of the
called procedure begins.

\item The dynamic extent is also entered when execution is not within
the dynamic extent and a continuation is invoked that was captured
(using {\cf call-with-current-continuation}) during the dynamic extent.

\item It is exited when the called procedure returns.

\item It is also exited when execution is within the dynamic extent and
a continuation is invoked that was captured while not within the
dynamic extent.
\end{itemize}

If a second call to {\cf dynamic-wind} occurs within the dynamic extent of the
call to \var{thunk} and then a continuation is invoked in such a way that the
\var{after}s from these two invocations of {\cf dynamic-wind} are both to be
called, then the \var{after} associated with the second (inner) call to
{\cf dynamic-wind} is called first.

If a second call to {\cf dynamic-wind} occurs within the dynamic extent of the
call to \var{thunk} and then a continuation is invoked in such a way that the
\var{before}s from these two invocations of {\cf dynamic-wind} are both to be
called, then the \var{before} associated with the first (outer) call to
{\cf dynamic-wind} is called first.

If invoking a continuation requires calling the \var{before} from one call
to {\cf dynamic-wind} and the \var{after} from another, then the \var{after}
is called first.

The effect of using a captured continuation to enter or exit the dynamic
extent of a call to \var{before} or \var{after} is undefined.

\begin{scheme}
(let ((path '())
      (c \#f))
  (let ((add (lambda (s)
               (set! path (cons s path)))))
    (dynamic-wind
      (lambda () (add 'connect))
      (lambda ()
        (add (call-with-current-continuation
               (lambda (c0)
                 (set! c c0)
                 'talk1))))
      (lambda () (add 'disconnect)))
    (if (< (length path) 4)
        (c 'talk2)
        (reverse path))))
    \lev (connect talk1 disconnect
               connect talk2 disconnect)
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{make-parameter}{ init}{procedure}
\proto{make-parameter}{ init converter}{procedure}}

Returns a new parameter object which is associated with the value
returned by the call \texttt{(\var{converter} \var{init})}.\index{parameterize}
If the conversion procedure \var{converter} is not specified the identity
function is used instead.

A parameter object is a procedure which accepts zero arguments and
returns its associated value.  The associated value may be changed
with {\cf parameterize}.

Here is a possible implementation of {\cf make-parameter} and {\cf
parameterize} suitable for an implementation with no threads.
Parameter objects are implemented here as procedures, using two
arbitrary unique objects \texttt{<param-set!>} and
\texttt{<param-convert>}:

\begin{scheme}
(define (make-parameter init . o)
  (let* ((converter (if (pair? o)
                        (car o)
                        (lambda (x) x)))
         (value (converter init)))
    (lambda args
      (if (pair? args)
          (cond
           ((eq? (car args) <param-set!>)
            (set! value (cadr args)))
           ((eq? (car args) <param-convert>)
            converter)
           (else
            (error "bad parameter syntax")))
          value))))%
\end{scheme}

{\cf Parameterize} then uses {\cf dynamic-wind} to dynamically rebind
the associated value:

\begin{scheme}
(define-syntax parameterize
  (syntax-rules ()
    ((parameterize ("step")
                   ((param value p old new) ...)
                   ()
                   body)
     (let ((p param) ...)
       (let ((old (p)) ...
             (new ((p <param-convert>) value)) ...)
         (dynamic-wind
          (lambda () (p <param-set!> new) ...)
          (lambda () . body)
          (lambda () (p <param-set!> old) ...)))))
    ((parameterize ("step")
                   args
                   ((param value) . rest)
                   body)
     (parameterize ("step")
                   ((param value p old new) . args)
                   rest
                   body))
    ((parameterize ((param value) ...) . body)
     (parameterize ("step")
                   ()
                   ((param value) ...)
                   body))))
\end{scheme}

Parameter objects can be used to specify configurable settings for a
computation without the need to explicitly pass the value to every
procedure in the call chain.

\begin{scheme}
(define radix
  (make-parameter
   10
   (lambda (x)
     (if (and (integer? x) (<= 2 x 16))
         x
         (error "invalid radix")))))

(define (f n) (number->string n (radix)))

(f 12)                                       \ev "12"
(parameterize ((radix 16))
  (f 12))                                    \ev "C"
(f 12)                                       \ev "12"

(radix 16)                                   \ev \unspecified

(parameterize ((radix 0))
  (f 12))                                    \ev \scherror
\end{scheme}
\end{entry}

\section{Exceptions}
\label{exceptionsection}

This section describes Scheme's exception-handling and
exception-raising procedures.
See also \ref{guard} for the {\cf guard} syntax.

Exception handlers are one-argument procedures that determine the
action the program takes when an exceptional situation is signalled.
The system implicitly maintains a current exception handler.

\index{current exception handler}The program raises an exception by
invoking the current exception handler, passing it an object
encapsulating information about the exception.  Any procedure
accepting one argument may serve as an exception handler and any
object may be used to represent an exception.

\begin{entry}{%
\proto{with-exception-handler}{ \var{handler} \var{thunk}}{procedure}}

\domain{\var{Handler} must be a procedure and should accept one argument.
\var{Thunk} must be a procedure that accepts zero arguments.}  The {\cf
with-exception-handler} procedure returns the results of invoking
\var{thunk}.  \var{Handler} is installed as the current
exception handler for the dynamic extent (as determined by {\cf
  dynamic-wind}) of the invocation of \var{thunk}.

%% \implresp The implementation must check the restrictions on
%% \var{handler} to the extent performed by applying it as described
%% when it is called as a result of a call to {\cf raise} or {\cf
%%   raise-continuable}.
%% An implementation may check whether \var{handler} is an appropriate argument
%% before applying it.

\todo{The above seems to just be saying that we shouldn't check if
  handler is applicable unless an exception actually reaches it.  Is
  this worth stating?}
\end{entry}

\begin{entry}{%
\proto{raise}{ \var{obj}}{procedure}}

Raises a exception by invoking the current exception
handler on \var{obj}. The handler is called with a continuation whose
dynamic extent is that of the call to {\cf raise}, except that
the current exception handler is the one that was in place when the
handler being called was installed.  If the handler returns, an
exception is raised in the same dynamic extent as the handler.
\end{entry}

\begin{entry}{%
\proto{raise-continuable}{ \var{obj}}{procedure}}

Raises an exception by invoking the current
exception handler on \var{obj}. The handler is called with a
continuation that is equivalent to the continuation of the call to
{\cf raise-continuable}, with these two exceptions: (1) the current
exception handler is the one that was in place when the handler being
called was installed, and (2) if the handler being called returns,
then it will again become the current exception handler.  If the
handler returns, the values it returns become the values returned by
the call to {\cf raise-continuable}.
\end{entry}

\begin{entry}{%
\proto{error}{ \var{message} \var{obj} $\ldots$}{procedure}}

\domain{\var{Message} should be a string.}
A convenience procedure to raise an exception.  Equivalent to calling
{\cf raise} on an implementation-defined object which encapsulates
the information provided by \var{message} and any \var{obj}s.
\end{entry}

\begin{scheme}
(with-exception-handler
  (lambda (con)
    (cond
      ((string? con)
       (display con))
      (else
       (display "a warning has been issued")))
    42)
  (lambda ()
    (+ (raise-continuable "should be a number")
       23)))
   {\it prints:} should be a number
   \ev 65
\end{scheme}


\section{\tt{Eval}}

\begin{entry}{%
\proto{eval}{ expression environment-specifier}{eval module procedure}}

Evaluates \var{expression} in the specified environment and returns its value.
\var{Expression} must be a valid Scheme expression represented as data,
and \var{environment-specifier} must be a value returned by one of the
three procedures described below.
Implementations may extend {\cf eval} to allow non-expression programs
(definitions) as the first argument and to allow other
values as environments, with the restriction that {\cf eval} is not
allowed to create new bindings in the environments returned by
{\cf null-environment} or {\cf scheme-report-environment}.

\begin{scheme}
(eval '(* 7 3) (scheme-report-environment 5))
                                                   \ev  21

(let ((f (eval '(lambda (f x) (f x x))
               (null-environment 5))))
  (f + 10))
                                                   \ev  20
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{scheme-report-environment}{ version}{eval module procedure}
\proto{null-environment}{ version}{eval module procedure}}

\var{Version} must be the exact integer {\cf \integerversion},
corresponding to this revision of the Scheme report (the
Revised$^\integerversion$ Report on Scheme).
{\cf Scheme-report-environment} returns a specifier for an
environment that is empty except for all bindings defined in
this report that are either required or both optional and
supported by the implementation. {\cf Null-environment} returns
a specifier for an environment that is empty except for the
(syntactic) bindings for all syntactic keywords defined in
this report that are either required or both optional and
supported by the implementation.

Other values of \var{version} can be used to specify environments
matching past revisions of this report, but their support is not
required.  An implementation must signal an error if \var{version}
is neither {\cf \integerversion} nor another value supported by
the implementation.

The effect of assigning (through the use of {\cf eval}) a variable
bound in a {\cf scheme-report-environment}
(for example {\cf car}) is unspecified.  Thus the environments specified
by {\cf scheme-report-environment} may be immutable.

\end{entry}

\begin{entry}{%
\proto{interaction-environment}{}{repl module procedure}}

This procedure returns a specifier for the environment that
contains imple\-men\-ta\-tion-defined bindings, typically a superset of
those listed in the report.  The intent is that this procedure
will return the environment in which the implementation would evaluate
expressions dynamically typed by the user.

\end{entry}

\section{Input and output}

\subsection{Ports}
\label{portsection}

Ports represent input and output devices.  To Scheme, an input port is
a Scheme object that can deliver data upon command, while an output
port is a Scheme object that can accept data.\mainindex{port}
Whether the input and output port types are disjoint is
implementation-dependent.

Different {\em port types} operate on different data.  Scheme
imple\-men\-ta\-tions are required to support {\em character ports}
and {\em binary ports}, but may also provide other port types.

A character port supports reading or writing of individual characters
from or to a backing store containing characters
using {\cf read-char} and {\cf write-char} below, as well as operations
defined in terms of characters such as {\cf read} and {\cf write}.

A binary port supports reading or writing of individual bytes from
or to a backing store containing bytes using {\cf read-u8} and {\cf
write-u8}, below.
Whether the character and binary port types are disjoint is
implementation-dependent.

Ports can be used to access files, devices, and similar things on the host
system in which the Scheme program is running.

\begin{entry}{%
\proto{call-with-input-file}{ string proc}{file module procedure}
\proto{call-with-output-file}{ string proc}{file module procedure}}

\var{Proc} should be a procedure that accepts one argument.
For {\cf call-with-input-file},
the file named by \var{string} should already exist; for
{\cf call-with-output-file},
the effect is unspecified if the file
already exists. These procedures call \var{proc} with one argument: the
character port obtained by opening the named file for input or output
as if by {\cf open-input-file} or {\cf open-output-file}.  If the
file cannot be opened, an error is signalled.  If \var{proc} returns,
then the port is closed automatically and the value(s) yielded by the
\var{proc} is(are) returned.  If \var{proc} does not return, then 
the port will not be closed automatically unless it is possible to
prove that the port will never again be used for a read or write
operation.
%Scheme
%will not close the port unless it can prove that the port will never
%again be used for a read or write operation.

\begin{rationale}
Because Scheme's escape procedures have unlimited extent, it  is
possible to escape from the current continuation but later to escape back in. 
If implementations were permitted to close the port on any escape from the
current continuation, then it would be impossible to write portable code using
both {\cf call-with-current-continuation} and {\cf call-with-input-file} or
{\cf call-with-output-file}.
\todo{Pitman wants more said here; maybe encourage users to call
\var{close-foo-port}; maybe talk about process switches (?).}
\end{rationale} 
\end{entry}

\begin{entry}{%
\proto{call-with-port}{ port proc}{io module procedure}}

\var{Proc} must accept one argument.  The {\cf call-with-port}
procedure calls \var{proc} with \var{port} as an argument.  If
\var{proc} returns, \var{port} is closed automatically and the values
returned by \var{proc} are returned.

\end{entry}

\begin{entry}{%
\proto{input-port?}{ obj}{io module procedure}
\proto{output-port?}{ obj}{io module procedure}
\proto{character-port?}{ obj}{io module procedure}
\proto{binary-port?}{ obj}{io module procedure}
\proto{port?}{ obj}{io module procedure}}

Returns \schtrue{} if \var{obj} is an input port, output port, 
character port, binary port, or any
kind of port, respectively, otherwise returns \schfalse.

\todo{Won't necessarily return true after port is closed.}

\end{entry}


\begin{entry}{%
\proto{port-open?}{ port}{io module procedure}}

Returns \schtrue{} if \var{port} is still open and capable of
performing input or output, and \schfalse{} otherwise.

\todo{If a port is no longer a port after being closed, this should return false in those cases and not raise a domain error.}

\end{entry}


\begin{entry}{%
\proto{current-input-port}{}{io module procedure}
\proto{current-output-port}{}{io module procedure}
\proto{current-error-port}{}{io module procedure}}

Returns the current default input port, output port, or error port (an
output port), respectively.  These are parameter objects, which can be
overridden with {\cf parameterize} (see
section~\ref{make-parameter}). The initial bindings for each of these
are bound to system defined binary ports.

\end{entry}


\begin{entry}{%
\proto{with-input-from-file}{ string thunk}{file module procedure}
\proto{with-output-to-file}{ string thunk}{file module procedure}}

\var{Thunk} should be a procedure of no arguments.
For {\cf with-input-from-file},
the file named by \var{string} should already exist; for
{\cf with-output-to-file},
the effect is unspecified if the file
already exists.
The file is opened for input or output
as if by {\cf open-input-file} or {\cf open-output-file}, 
and the return port is made the default value returned by
{\cf current-input-port} or {\cf current-output-port}
(and is used by {\tt (read)}, {\tt (write \var{obj})}, and so forth),
and the
\var{thunk} is called with no arguments.  When the \var{thunk} returns,
the port is closed and the previous default is restored.
{\cf With-input-from-file} and {\cf with-output-to-file} return(s) the
value(s) yielded by \var{thunk}.
If an escape procedure
is used to escape from the continuation of these procedures, their
behavior is implementation dependent.

\todo{OK this with authors??}
%current continuation changes in such a way
%as to make it doubtful that the \var{thunk} will ever return.

\todo{Freeman:
Throughout this section I wanted to see ``the value of {\tt(current-input-port)}''
instead of ``the value returned by \var{current-input-port}''.  (Same for
\var{current-output-port}.)}


\end{entry}


\begin{entry}{%
\proto{open-input-file}{ string}{file module procedure}
\proto{open-binary-input-file}{ string}{file module procedure}}
 
Takes a \var{string} for an existing file and returns a character
input port or binary input port capable of delivering data from the
file.  If the file cannot be opened, an error is signalled.

\end{entry}


\begin{entry}{%
\proto{open-output-file}{ string}{file module procedure}
\proto{open-binary-output-file}{ string}{file module procedure}}

Takes a \var{string} naming an output file to be created and returns a
character output port or binary output port capable of writing
data to a new file by that name.  If the file cannot be opened,
an error is signalled.  If a file with the given name already exists,
the effect is unspecified.

\end{entry}


\begin{entry}{%
\proto{close-input-port}{ port}{io module procedure}
\proto{close-output-port}{ port}{io module procedure}
\proto{close-port}{ port}{io module procedure}}

Closes the file associated with \var{port}, rendering the \var{port}
incapable of delivering or accepting data.  \todo{But maybe a no-op
on some ports, e.g. terminals or editor buffers.}  It is an error
to apply the first two procedures to a port which is not an input
or output port, respectively.
These routines have no effect if the file has already been closed.
The value returned is unspecified.

\todo{Ramsdell:  Some note is needed explaining why there are two
different close procedures.}

\todo{A port isn't necessarily still a port after it has been closed?}

\end{entry}

%% \subsection{String Ports}
%% \label{stringportsection}

\begin{entry}{%
\proto{open-input-string}{ string}{io module procedure}}

Takes a string and returns a character input port that delivers
characters from the string.

%% \begin{scheme}
%% (define p
%%   (open-input-string "(a . (b . (c . ()))) 34"))

%% (input-port? p)                 \ev  \schtrue
%% (read p)                        \ev  (a b c)
%% (read p)                        \ev  34
%% (eof-object? (peek-char p))     \ev  \schtrue
%% \end{scheme}
\end{entry}

\begin{entry}{%
\proto{open-output-string}{}{io module procedure}}

Returns a character output port that will accumulate characters for
retrieval by {\cf get-output-string}.

%% \begin{scheme}
%% (let ((q (open-output-string))
%%       (x '(a b c)))
%%   (write (car x) q)
%%   (write (cdr x) q)
%%   (get-output-string q))        \ev  "a(b c)"
%% \end{scheme}
\end{entry}

\begin{entry}{%
\proto{get-output-string}{ port}{io module procedure}}

Given an output port created by {\cf open-output-string}, returns a
string consisting of the characters that have been output to the port
so far.
\end{entry}


%% \subsection{Bytevector Ports}
%% \label{bytevectorportsection}

\begin{entry}{%
\proto{open-input-bytevector}{ bytevector}{io module procedure}}

Takes a bytevector and returns a binary input port that delivers
bytes from the bytevector.

%% \begin{scheme}
%% (define p
%%   (open-input-bytevector "(a . (b . (c . ()))) 34"))

%% (input-port? p)                 \ev  \schtrue
%% (read p)                        \ev  (a b c)
%% (read p)                        \ev  34
%% (eof-object? (peek-char p))     \ev  \schtrue
%% \end{scheme}
\end{entry}

\begin{entry}{%
\proto{open-output-bytevector}{}{io module procedure}}

Returns a binary output port that will accumulate bytes for
retrieval by {\cf get-output-bytevector}.

%% \begin{scheme}
%% (let ((q (open-output-string))
%%       (x '(a b c)))
%%   (write (car x) q)
%%   (write (cdr x) q)
%%   (get-output-string q))        \ev  "a(b c)"
%% \end{scheme}
\end{entry}

\begin{entry}{%
\proto{get-output-bytevector}{ port}{io module procedure}}

Given an output port created by {\cf open-output-bytevector}, returns a
bytevector consisting of the bytes that have been output to the port
so far.
\end{entry}


\subsection{Input}
\label{inputsection}

\noindent \hbox{ }  %???
\vspace{-5ex}
\todo{The input routines have some things in common, maybe explain here.}

\begin{entry}{%
\proto{read}{}{read module procedure}
\rproto{read}{ port}{read module procedure}}

{\cf Read} converts external representations of Scheme objects into the
objects themselves.  That is, it is a parser for the nonterminal
\meta{datum} (see sections~\ref{datum} and
\ref{listsection}).  {\cf Read} returns the next
object parsable from the given character input \var{port}, updating
\var{port} to point to
the first character past the end of the external representation of the object.

\vest If an end of file is encountered in the input before any
characters are found that can begin an object, then an end of file
object is returned.  \todo{} The port remains open, and further attempts
to read will also return an end of file object.  If an end of file is
encountered after the beginning of an object's external representation,
but the external representation is incomplete and therefore not parsable,
an error is signalled.

The \var{port} argument may be omitted, in which case it defaults to the
value returned by {\cf current-input-port}.  It is an error to read from
a closed port.
\end{entry}

\begin{entry}{%
\proto{read-char}{}{io module procedure}
\rproto{read-char}{ port}{io module procedure}}

Returns the next character available from the character input \var{port},
updating
the \var{port} to point to the following character.  If no more characters
are available, an end of file object is returned.  \var{Port} may be
omitted, in which case it defaults to the value returned by {\cf current-input-port}.

\end{entry}


\begin{entry}{%
\proto{peek-char}{}{io module procedure}
\rproto{peek-char}{ port}{io module procedure}}

Returns the next character available from the character input \var{port},
{\em without} updating
the \var{port} to point to the following character.  If no more characters
are available, an end of file object is returned.  \var{Port} may be
omitted, in which case it defaults to the value returned by {\cf current-input-port}.

\begin{note}
The value returned by a call to {\cf peek-char} is the same as the
value that would have been returned by a call to {\cf read-char} with the
same \var{port}.  The only difference is that the very next call to
{\cf read-char} or {\cf peek-char} on that \var{port} will return the
value returned by the preceding call to {\cf peek-char}.  In particular, a call
to {\cf peek-char} on an interactive port will hang waiting for input
whenever a call to {\cf read-char} would have hung.
\end{note}

\end{entry}


\begin{entry}{%
\proto{eof-object?}{ obj}{io module procedure}}

Returns \schtrue{} if \var{obj} is an end of file object, otherwise returns
\schfalse.  The precise set of end of file objects will vary among
implementations, but in any case no end of file object will ever be an object
that can be read in using {\cf read}.

\end{entry}


\begin{entry}{%
\proto{char-ready?}{}{io module procedure}
\rproto{char-ready?}{ port}{io module procedure}}

Returns \schtrue{} if a character is ready on the character input \var{port} and
returns \schfalse{} otherwise.  If {\cf char-ready} returns \schtrue{} then
the next {\cf read-char} operation on the given \var{port} is guaranteed
not to hang.  If the \var{port} is at end of file then {\cf char-ready?}\
returns \schtrue.  \var{Port} may be omitted, in which case it defaults to
the value returned by {\cf current-input-port}.

\begin{rationale}
{\cf Char-ready?}\ exists to make it possible for a program to
accept characters from interactive ports without getting stuck waiting for
input.  Any input editors associated with such ports must ensure that
characters whose existence has been asserted by {\cf char-ready?}\ cannot
be rubbed out.  If {\cf char-ready?}\ were to return \schfalse{} at end of
file, a port at end of file would be indistinguishable from an interactive
port that has no ready characters.
\end{rationale}
\end{entry}

\begin{entry}{%
\proto{read-u8}{}{io module procedure}
\rproto{read-u8}{ port}{io module procedure}}

Returns the next byte available from the binary input \var{port},
updating the \var{port} to point to the following byte.  
If no more bytes are
available, an end of file object is returned.  \var{Port} may be
omitted, in which case it defaults to the value returned by {\cf
  current-input-port}.

\end{entry}


\begin{entry}{%
\proto{peek-u8}{}{io module procedure}
\rproto{peek-u8}{ port}{io module procedure}}

Returns the next byte available from the binary input \var{port},
{\em without} updating the \var{port} to point to the following
byte.  If no more bytes are available, an end of file object is
returned.  \var{Port} may be omitted, in which case it defaults to the
value returned by {\cf current-input-port}.

\end{entry}


\begin{entry}{%
\proto{u8-ready?}{}{io module procedure}
\rproto{u8-ready?}{ port}{io module procedure}}

Returns \schtrue{} if a byte is ready on the binary input \var{port}
and returns \schfalse{} otherwise.  If {\cf u8-ready?} returns
\schtrue{} then the next {\cf read-u8} operation on the given
\var{port} is guaranteed not to hang.  If the \var{port} is at end of
file then {\cf u8-ready?}\ returns \schtrue.  \var{Port} may be
omitted, in which case it defaults to the value returned by {\cf
  current-input-port}.

\begin{note}
If {\cf u8-ready?} returns \schtrue{}, a subsequent {\cf read-char}
operation may still hang.
\end{note}
\end{entry}

\subsection{Output}
\label{outputsection}

% We've got to put something here to fix the indentation!!
\noindent \hbox{}
\vspace{-5ex}

\begin{entry}{%
\proto{write}{ obj}{write module procedure}
\rproto{write}{ obj port}{write module procedure}}

Writes a written representation of \var{obj} to the given character output
\var{port}.  Strings
that appear in the written representation are enclosed in doublequotes, and
within those strings backslash and doublequote characters are
escaped by backslashes.  Symbols that contain non-ASCII characters
are escaped either with inline hex escapes or with vertical bars.
Character objects are written using the {\cf \#\backwhack} notation.
Shared list structure is represented using labels.
{\cf Write} returns an unspecified value.  The
\var{port} argument may be omitted, in which case it defaults to the value
returned by {\cf current-output-port}.

\end{entry}

\begin{entry}{%
\proto{write-simple}{ obj}{write module procedure}
\rproto{write-simple}{ obj port}{write module procedure}}

{\cf Write-simple} is the same as {\cf write}, except that shared structure is
not represented using labels.  This may cause {\cf write-simple} not to
terminate if \var{obj} contains circular structure.

\end{entry}


\begin{entry}{%
\proto{display}{ obj}{write module procedure}
\rproto{display}{ obj port}{write module procedure}}

Writes a representation of \var{obj} to the given character output \var{port}.
Strings that appear in the written representation are not enclosed in
doublequotes, and no characters are escaped within those strings.  
Symbols are not escaped.  Character
objects appear in the representation as if written by {\cf write-char}
instead of by {\cf write}.  {\cf Display} returns an unspecified value.
The \var{port} argument may be omitted, in which case it defaults to the
value returned by {\cf current-output-port}.

\begin{rationale}
{\cf Write} is intended
for producing mach\-ine-readable output and {\cf display} is for producing
human-readable output.  
\end{rationale}
\end{entry}


\begin{entry}{%
\proto{newline}{}{io module procedure}
\rproto{newline}{ port}{io module procedure}}

Writes an end of line to character output \var{port}.  Exactly how this
is done differs
from one operating system to another.  Returns an unspecified value.
The \var{port} argument may be omitted, in which case it defaults to the
value returned by {\cf current-output-port}.

\end{entry}


\begin{entry}{%
\proto{write-char}{ char}{io module procedure}
\rproto{write-char}{ char port}{io module procedure}}

Writes the character \var{char} (not an external representation of the
character) to the given character output \var{port} and returns an unspecified
value.  The
\var{port} argument may be omitted, in which case it defaults to the value
returned by {\cf current-output-port}.

\end{entry}

\begin{entry}{%
\proto{write-u8}{ byte}{io module procedure}
\rproto{write-u8}{ byte port}{io module procedure}}

Writes the \var{byte} to
the given binary output \var{port} and returns an unspecified value.
The \var{port} argument may be omitted, in which case it defaults to
the value returned by {\cf current-output-port}.

\end{entry}

\begin{entry}{%
\proto{flush-output-port}{}{io module procedure}
\rproto{flush-output-port}{ port}{io module procedure}}

Flushes any buffered output from the buffer of output-port to the
underlying file or device and returns an unspecified value.
The \var{port} argument may be omitted, in which case it defaults to
the value returned by {\cf current-output-port}.

\end{entry}


\subsection{System interface}

Questions of system interface generally fall outside of the domain of this
report.  However, the following operations are important enough to
deserve description here.


\begin{entry}{%
\proto{load}{ filename}{load module procedure}}

\todo{Fix}

%\domain{\var{Filename} should be a string naming an existing file
%containing Scheme source code.} The {\cf load} procedure reads
An implementation-dependent operation is used to transform
\var{filename} into the name of an existing file
containing Scheme source code.  The {\cf load} procedure reads
expressions and definitions from the file and evaluates them
sequentially.  It is unspecified whether the results of the expressions
are printed.  The {\cf load} procedure does not affect the values
returned by {\cf current-input-port} and {\cf current-output-port}.
{\cf Load} returns an unspecified value.

\end{entry}

\begin{entry}{%
\proto{include}{ filename}{load module syntax}
\proto{include-ci}{ filename}{load module syntax}}

{\cf Include} and {\cf include-ci} are similar to {\cf load} except
that they are syntax which expands into the expressions and
definitions from the file as though wrapped in a {\cf begin} form.
Thus it can be used to include internal definitions and otherwise
interact with the current lexical scope.  In these forms the
\var{filename} must be a string literal.

\begin{rationale}
For portability, {\cf load} and {\cf include} must operate on source files.
Their operation on other kinds of files necessarily varies among
implementations.
\end{rationale}
\end{entry}

\begin{entry}{%
\proto{file-exists?}{ filename}{file module procedure}}

\var{Filename} must be a string. The {\cf file-exists?} procedure returns
\schtrue{} if the named file exists at the time the procedure is called,
\schfalse{} otherwise.

\end{entry}

\begin{entry}{%
\proto{delete-file}{ filename}{file module procedure}}

\var{Filename} must be a string. The {\cf delete-file} procedure deletes the
named file if it exists and can be deleted, and returns an unspecified
value.  If the file does not exist or cannot be deleted, an exception
is raised.

\end{entry}

\begin{entry}{%
\proto{command-line}{}{process-context module procedure}}

Returns the command line arguments passed to the process as a list of
strings.
\end{entry}

\begin{entry}{%
\proto{exit}{}{process-context module procedure}
\rproto{exit}{ obj}{process-context module procedure}}

Exits the running program and communicates an exit value to the
operating system.  If no argument is supplied, the {\cf exit}
procedure should communicate to the operating system that the program
exited normally.  If an argument is supplied, the exit procedure
should translate the argument into an appropriate exit value for the
operating system. If obj is \schfalse{}, the exit is assumed to be
abnormal.

\end{entry}

\todo{Shinn: Do we need any description of what an environment variable is?}

\begin{entry}{%
\proto{get-environment-variable}{ name}{process-context module procedure}}

\var{Name} must be a string.  Returns the value of the named
environment variable as a string, or \schfalse{} if the named
environment variable is not found.  {\cf get-environment-variable} may
use locale-setting information to encode the name and decode the value
of the environment variable.  If {\cf get-environment-variable} can't
decode the value it may raise an exception.

\begin{scheme}
(get-environment-variable "PATH") \lev "/usr/local/bin:/usr/bin:/bin"
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{get-environment-variables}{}{process-context module procedure}}

Returns the names and values of all the environment variables as an
a-list, where the car of each entry is the name of an environment
variable and the cdr is the value as would be returned by
{\cf get-environment-variable}.  The order of the list is unspecified.

\begin{scheme}
(get-environment-variables) \lev (("USER" . "root") ("HOME" . "/"))
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{current-second}{}{time module procedure}}

Returns an exact integer representing the current second of the Posix
epoch, which began on 00:00:00 on 1 January 1970, Coordinated
Universal Time.  Whether leap seconds are included is
implementation-defined.
\end{entry}

\begin{entry}{%
\proto{current-jiffy}{}{time module procedure}}

Returns an exact integer representing the number of jiffies (arbitrary
elapsed time units) since an arbitrary epoch which may vary between
runs of a program.
\end{entry}

\begin{entry}{%
\proto{jiffies-per-second}{}{time module procedure}}

Returns an exact integer representing the number of jiffies per SI
second. This value is an implementation-specified constant.
\end{entry}

%% \begin{entry}{%
%% \proto{transcript-on}{ filename}{procedure}\nopagebreak{}
%% \proto{transcript-off}{}{procedure}}

%% \domain{\var{Filename} must be a string naming an output file to be
%% created.} The effect of {\cf transcript-on} is to open the named file
%% for output, and to cause a transcript of subsequent interaction between
%% the user and the Scheme system to be written to the file.  The
%% transcript is ended by a call to {\cf transcript-off}, which closes the
%% transcript file.  Only one transcript may be in progress at any time,
%% though some implementations may relax this restriction.  The values
%% returned by these procedures are unspecified.

%% %\begin{note}
%% %These procedures are redundant in some systems, but
%% %systems that need them should provide them.
%% %\end{note}
%% \end{entry}
