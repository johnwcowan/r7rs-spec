% Lexical structure

%%\vfill\eject
\chapter{Lexical conventions}

This section gives an informal account of some of the lexical
conventions used in writing Scheme programs.  For a formal syntax of
Scheme, see section~\ref{BNF}.

%% \vest Upper and lower case forms of a letter are never distinguished
%% except within character and string constants.  For example, {\cf Foo} is
%% the same identifier as {\cf FOO}, and {\tt\#x1AB} is the same number as
%% {\tt\#X1ab}.

\section{Identifiers}
\label{syntaxsection}

Most identifiers\mainindex{identifier} allowed by other programming
languages are also acceptable to Scheme.  The precise rules for forming
identifiers vary among implementations of Scheme, but in all
implementations a sequence of letters, digits, and ``extended alphabetic
characters'' that does not have a prefix which is a valid number,
other than the \ide{.} token used in the list syntax, is an identifier.
Here are some examples of identifiers:

\begin{scheme}
lambda                   q
list->vector             +soup+
{+}                        V17a
<=?                      a34kTMNs
->string                 ...
the-word-recursion-has-many-meanings%
\end{scheme}

Extended alphabetic characters may be used within identifiers as if
they were letters.  The following are extended alphabetic characters:

\begin{scheme}
!\ \$ \% \verb"&" * + - . / :\ < = > ? @ \verb"^" \verb"_" \verb"~" %
\end{scheme}

In addition, any character can be used within an identifier when
specified via an \meta{inline hex escape}.  For example, the
identifier \verb|H\x65;llo| is the same as the identifier
\verb|Hello|, and in an implementation which has the appropriate
Unicode character the identifier \verb|\x3BB;| is the same as the
identifier $\lambda$.

As a convenience, idenfitiers may also be written as a sequence of
characters enclosed within vertical bars ({\cf $|$}), analogous to
string literals.  Vertical bars and other characters can be included
in the identifier with an \meta{inline hex escape}.  Thus the
identifier \verb+|foo bar|+ is the same as the identifier
\verb+foo\x20;bar+.

See section~\ref{extendedalphas} for a formal syntax of identifiers.

\vest Identifiers have two uses within Scheme programs:
\begin{itemize}
\item Any identifier may be used as a variable\index{variable}
 or as a syntactic keyword\index{syntactic keyword}
(see sections~\ref{variablesection} and~\ref{macrosection}).

\item When an identifier appears as a literal or within a literal
(see section~\ref{quote}), it is being used to denote a {\em symbol}
(see section~\ref{symbolsection}).
\end{itemize}

In contrast with earlier revisions of the report~\cite{R5RS}, the
syntax of data distinguishes upper and lower case in identifiers and in
characters specified via their names.

Implementors may wish to support case-insensitive syntax for backward
compatibility or other reasons.
If they do so, they should adopt the following optional directives
to control case folding.

\begin{entry}{%
{\cf{}\#!fold-case}\sharpbangindex{fold-case}\\
{\cf{}\#!no-fold-case}\sharpbangindex{no-fold-case}}

These directives may appear anywhere comments may appear and are
treated as comments, except that they affect the reading of subsequent
lexemes.
The {\cf{}\#!fold-case} causes the reader to case-fold
each \meta{identifier} and \meta{character name}.
The {\cf{}\#!no-fold-case} directive causes the reader to return
to the default, non-folding behavior.
\end{entry}

%\label{keywordsection}
%The following identifiers are syntactic keywords, and should not be used
%as variables:
%
%\begin{scheme}
%=>           do            or
%and          else          quasiquote
%begin        if            quote
%case         lambda        set!
%cond         let           unquote
%define       let*          unquote-splicing
%delay        letrec%
%\end{scheme}
%
%Some implementations allow all identifiers, including syntactic
%keywords, to be used as variables.  This is a compatible extension to
%the language, but ambiguities in the language result when the
%restriction is relaxed, and the ways in which these ambiguities are
%resolved vary between implementations.


\section{Whitespace and comments}

\defining{Whitespace} characters are spaces and newlines.
(Implementations typically provide additional whitespace characters such
as tab or page break.)  Whitespace is used for improved readability and
as necessary to separate tokens from each other, a token being an
indivisible lexical unit such as an identifier or number, but is
otherwise insignificant.  Whitespace may occur between any two tokens,
but not within a token.  Whitespace may also occur inside a string,
where it is significant.

The lexical syntax includes several comment forms. In all cases,
comments are invisible to Scheme, except that they act as delimiters,
so, for example, a comment cannot appear in the middle of an
identifier or representation of a number object.

A semicolon ({\tt;}) indicates the start of a line
comment.\mainindex{comment}\mainschindex{;}  The comment continues to the
end of the line on which the semicolon appears.

Another way to indicate a comment is to prefix a \hyper{datum}
(cf.\ section~\ref{datumsyntax}) with {\tt \#;}\sharpindex{;}, possibly with
\meta{interlexeme space} before the \hyper{datum}.  The comment consists of
the comment prefix {\tt \#;} and the \hyper{datum} together.  This
notation is useful for ``commenting out'' sections of code.

Block comments may be indicated with properly nested {\tt
  \#|}\index{#"|@\texttt{\sharpsign\verticalbar}}\index{"|#@\texttt{\verticalbar\sharpsign}}
and {\tt |\#} pairs.

\begin{scheme}
\#|
   The FACT procedure computes the factorial
   of a non-negative integer.
|\#
(define fact
  (lambda (n)
    (if (= n 0)
        \#;(= n 1)
        1        ;Base case: return 1
        (* n (fact (- n 1))))))%
\end{scheme}


\section{Other notations}

\todo{Rewrite?}

For a description of the notations used for numbers, see
section~\ref{numbersection}.

\begin{description}{}{}

\item[{\tt.\ + -}]
These are used in numbers, and may also occur anywhere in an identifier.
A delimited plus or minus sign by itself
is also an identifier.
A delimited period (not occurring within a number or identifier) is used
in the notation for pairs (section~\ref{listsection}), and to indicate a
rest-parameter in a  formal parameter list (section~\ref{lambda}).

\item[\tt( )]
Parentheses are used for grouping and to notate lists
(section~\ref{listsection}).

\item[\singlequote]
The single quote character is used to indicate literal data (section~\ref{quote}).

\item[\backquote]
The backquote character is used to indicate almost-constant
data (section~\ref{quasiquote}).

\item[\tt, ,@]
The character comma and the sequence comma at-sign are used in conjunction
with backquote (section~\ref{quasiquote}).

\item[\tt"]
The double quote character is used to delimit strings (section~\ref{stringsection}).

\item[\backwhack]
Backslash is used in the syntax for character constants
(section~\ref{charactersection}) and as an escape character within string
constants (section~\ref{stringsection}).

% A box used because \verb is not allowed in command arguments.
\setbox0\hbox{\tt \verb"[" \verb"]" \verb"{" \verb"}" \verb"|"}
\item[\copy0]
Left and right square brackets and curly braces and vertical bar
are reserved for possible future extensions to the language.

\item[\sharpsign] Sharp sign is used for a variety of purposes depending on
the character that immediately follows it:

\item[\schtrue{} \schfalse{}]
These are the boolean constants (section~\ref{booleansection}).

\item[\sharpsign\backwhack]
This introduces a character constant (section~\ref{charactersection}).

\item[\sharpsign\tt(]
This introduces a vector constant (section~\ref{vectorsection}).  Vector constants
are terminated by~{\tt)}~.

\item[{\tt\#e \#i \#b \#o \#d \#x}]
These are used in the notation for numbers (section~\ref{numbernotations}).

\item[\hyper{digit}]
These are used for labeling and referencing other literal data (section~\ref{labelsection}).

\end{description}
