\extrapart{Notes}


\subsection*{Incompatibilities with \rfivers}
\label{incompatibilities}

This section enumerates the incompatibilities between this report and
the ``Revised$^5$ report''~\cite{R5RS}.

{\em This list is not authoritative, but is believed to be correct and complete.}


\begin{itemize}

\item Case sensitivity is now the default in symbols and character names.
This means that code written under the assumption that symbols could be
written {\cf FOO} or {\cf Foo} in some contexts and {\cf foo} in other contexts
must either be changed, be marked with the new {\cf \#!fold-case} directive,
or be included in a library using the {\cf include-ci} library declaration.
All standard identifiers are entirely in lower case.

\item The {\cf syntax-rules} construct now recognizes {\em \_} (underscore) 
as a wildcard, which means it cannot be used as a syntax variable.
It can still be used as a literal, however.

\item The \rfivers\ procedures {\cf exact->inexact} and {\cf inexact->exact}
have been renamed to their \rsixrs\ names, {\cf inexact} and {\cf exact},
respectively, as these names are shorter and more correct.
The former names are still available in the \rfivers\ compatibility library.

\item The guarantee that string comparison (with {\cf string<?} and the
related predicates) is a lexicographical extension of character comparison
(with {\cf char<?} and the related predicates) has been removed.  The former
set provide an implementation-defined comparison as in \rfivers; the latter
set provide comparison by Unicode scalar value.

\item Support for the \# character in numeric literals is no longer required.

\item The procedures {\cf transcript-on} and {\cf transcript-off} have been removed.

\end{itemize}

\subsection*{Other language changes since \rfivers}
\label{differences}
This section enumerates the additional differences between this report and
the ``Revised$^5$ report''~\cite{R5RS}.

{\em This list is not authoritative, but has been verified as closely
as possible.  It may be incomplete.}


\begin{itemize}

\item Various minor ambiguities and unclarities in \rfivers\ have been cleaned up.

\item Libraries have been added as a new program structure to improve
encapsulation and sharing of code.  Some existing and new identifiers
have been factored out into separate libraries.
Libraries can be imported into other libraries or main programs, with
controlled exposure and renaming of identifiers.
The contents of a library can be made conditional on the features of
the implementation on which it is to be used.

\item Exceptions can now be signaled explicitly with {\cf raise},
{\cf raise-continuable} or {\cf error}, and can be handled with {\cf
with-exception-handler} and the {\cf guard} syntax.
Any object can specify an error condition; the implementation-defined
conditions signaled by {\cf error} have a predicate to detect them and accessor functions to
retrieve the arguments passed to {\cf error}.
Conditions signaled by {\cf read} and by file-related procedures
also have predicates to detect them.

\item New disjoint types supporting access to multiple fields can be
generated with SRFI 9's {\cf define-record-type}.

\item Parameter objects can be created with {\cf make-parameter}, and
dynamically rebound with {\cf parameterize}.

\item {\em Bytevectors}, homogeneous vectors of integers in the range
$[0, 255]$, have been added as a new disjoint type.
A subset of the procedures available for vectors is provided.  Bytevectors
can be converted to and from strings in accordance with the UTF-8 character encoding.
Bytevectors have a datum representation and evaluate to themselves.

\item Vector constants evaluate to themselves.

\item The procedure {\cf read-line} is provided to make line-oriented textual input
simpler.

\item {\em Ports} can now be designated as {\em textual} or {\em
binary} ports, with new procedures for reading and writing binary
data.
The new predicates {\cf input-port-open?} and {\cf output-port-open?} return whether a port is open or closed.

\item {\em String ports} have been added as a way to read and write
characters to and from strings, and {\em bytevector ports} to read
and write bytes to and from bytevectors.

\item The procedures {\cf current-input-port} and {\cf current-output-port} are now
parameter objects, as is the newly introduced {\cf
current-error-port}.

\item The {\cf syntax-rules} construct now allows
the ellipsis symbol to be specified explicitly instead of the default
{\cf ...}, allows template escapes with an ellipsis-prefixed list, and
allows tail patterns to follow an ellipsis pattern.

\item The {\cf syntax-error} syntax has been added as a way to signal immediate
and more informative errors when a macro is expanded.

\item Internal syntax definitions are now allowed wherever
internal definitions are.

\item The {\cf letrec*} binding construct has been added, and internal {\cf define} 
is specified in terms of it.

\item Support for capturing multiple values has been enhanced with {\cf
define-values}, {\cf let-values}, and {\cf let*-values}.
Standard forms which introduce a body now permit passing zero or more than
one value to the continuations of all non-final forms of the body.

\item The {\cf case} conditional now supports {\tt =>} syntax
analogous to {\cf cond} not only in regular clauses but in the {\cf
else} clause as well.

\item To support dispatching on the number of arguments passed to a
procedure, {\cf case-lambda} has been added in its own library.

\item The convenience conditionals {\cf when} and {\cf unless} have been added.

\item Positive infinity, negative infinity, NaN, and negative inexact zero have been added
to the numeric tower as inexact values with the written
representations {\tt +inf.0}, {\tt -inf.0}, {\tt +nan.0}, and {\cf -0.0}
respectively.  Support for them is not required.
The representation {\tt -nan.0} is synonymous with {\tt +nan.0}.

\item The procedures {\cf map} and {\cf for-each} are now required to terminate on
the shortest list when the inputs have different lengths.

\item The procedures {\cf member} and {\cf assoc} now take an optional third argument
specifying the equality predicate to be used.

\item The procedures {\cf exact-integer?}, {\cf square},
and {\cf exact-integer-sqrt} have been added.

\item The procedures {\cf make-list}, {\cf list-copy}, {\cf list-set!},
{\cf string-map}, {\cf string-for-each}, {\cf string->vector}, 
{\cf vector-append},
{\cf vector-copy}, {\cf vector-map}, {\cf vector-for-each}, 
{\cf vector->string}, {\cf vector-copy!}, and {\cf string-copy!}
have been added to round out the sequence operations.
Some of these support processing of part of a string or vector using
optional start and end arguments.

\item Implementations may provide any subset of the full Unicode
repertoire that includes ASCII, but implementations must support any
such subset in a way consistent with Unicode.
Various character and string procedures have been extended accordingly.
String comparison remains implementation-dependent, and is no longer
required to be consistent with character comparison, which is based
on Unicode scalar values.
The new {\cf digit-value} procedure has been added to obtain the numerical
value of a numeric character.

\item There are now two additional comment syntaxes: {\tt \#;} to
skip the next datum, and {\tt \#| ... |\#}
for nestable block comments.

\item Data prefixed with datum labels {\tt \#<n>=} can be referenced
with {\tt \#<n>\#}, allowing for reading and writing of data with
shared structure.

\item Strings and symbols now allow mnemonic and numeric escape
sequences, and the list of named characters has been extended.

\item The procedures {\cf file-exists?}\ and {\cf delete-file} are available in the
{\tt (scheme file)} library.

\item An interface to the system environment and command line is
available in the {\tt (scheme process-context)} library.

\item Procedures for accessing time-related values are available in the
{\tt (scheme time)} library.

\item A less irregular set of integer division operators is provided
with new and clearer names.

\item The {\cf load} procedure now accepts a second argument specifying the environment to
load into.

\item The semantics of read-eval-print loops are now partly prescribed,
requiring the redefinition of procedures, but not syntax keywords, to have retroactive effect.

\end{itemize}

\subsection*{Incompatibilities with the main \rsixrs\ document}
This section enumerates the incompatibilities between \rsevenrs~and
the ``Revised$^6$ report''~\cite{R6RS}.

{\em This list is not authoritative, and may be incomplete.}

\begin{itemize}
\item The syntax of the library system was deliberately chosen to be
syntactically different from \rsixrs, using {\cf define-library} instead of
{\cf library} in order to allow easy disambiguation between \rsixrs\
and \rsevenrs\ libraries.

\item The library system does not support phase distinctions, which
are unnecessary in the absence of low-level macros (see below),
nor does it support versioning, which is an important feature but deserves more
experimentation before being standardized.

\item Putting an extra level of indirection around the library body
allows room for extensibility. The \rsixrs\ syntax provides two positional
forms which must be present and must have the correct keywords,
{\cf export} and {\cf import}, which does not allow for unambiguous
extensions. The Working Group considers extensibility to be important,
and so chose a syntax which provides
a clear separation between the library declarations and the Scheme code
which makes up the body.

\item The {\cf include} library declaration
makes it easier to include separate files, 
and the {\cf include-ci} variant allows legacy 
case-insensitive code to be incorporated.

\item The {\cf cond-expand} library declaration based on SRFI 0 allows for a more
flexible alternative to the \rsixrs\ {\cf .impl.sls} file naming
convention.
The list of identifiers that {\cf cond-expand} treats as true is
available at run time using the {\cf features} procedure.

\item Since the \rsevenrs\ library system is straightforward, we expect
that \rsixrs\ implementations will be able to support the {\cf define-library}
syntax in addition to their {\cf library} syntax.

\item The grouping of standardized identifiers into libraries is different from the \rsixrs\
approach. In particular, procedures which are optional either expressly
or by implication in \rfivers\ have been removed from the base library.
Only the base library is an absolute requirement.

\item Identifier syntax is not provided. This is a useful feature in
some situations, but the existence of such macros means that neither
programmers nor other macros can look at an identifier in an evaluated
position and know it is a reference --- this in a sense makes all macros
slightly weaker. Individual implementations are encouraged to continue
experimenting with this and other extensions before further standardization is done.

\item Internal syntax definitions are allowed, but all references to syntax
must follow the definition; the {\cf even}/{\cf odd} example given in
\rsixrs\ is not allowed.

\item The \rsixrs\ exception system was incorporated as-is, but the condition
types have been left unspecified.  Specific errors that must be signaled
in \rsixrs\ remain errors in \rsevenrs, allowing implementations to provide
their own extensions.  There is no discussion of safety.

\item Full Unicode support is not required.
Normalization is not provided.
Character comparisons are
defined by Unicode, but string comparisons are implementation-dependent,
and therefore need not be the lexicographic mapping of the corresponding
character comparisons (an incompatibility with \rfivers). Non-Unicode
characters are permitted.

\item The full numeric tower is optional as in \rfivers, but optional support for IEEE
infinities, NaN, and {\mbox -0.0} was adopted from \rsixrs. Most clarifications on
numeric results were also adopted, but the \rsixrs\ procedures {\cf real-valued?},
{\cf rational-valued?}, and {\cf integer-valued}? were not. 
The \rsixrs\ division operators {\cf div}, {\cf mod}, {\cf div-and-mod}, {\cf
div0}, {\cf mod0} and {\cf div0-and-mod0} are not provided.

\item When a result is unspecified, it is still required to be a single value,
in the interests of \rfivers\ compatibility. However, non-final expressions
in a body may return any number of values.

\item Because of widespread SRFI 1 support and extensive code
that uses it, the semantics of {\cf map} and {\cf for-each} have been changed to use
the SRFI 1 early termination behavior. Likewise
{\cf assoc} and {\cf member} take an optional {\cf equal?} argument as in SRFI 1,
instead of the separate {\cf assp} and {\cf memp} procedures of \rsixrs.

\item The {\cf log} procedure now accepts a second argument specifying
the logarithm base.

\item The \rsixrs~{\cf quasiquote} clarifications have been adopted, but the Working Group has not seen
convincing enough examples of multiple-argument {\cf unquote} and
{\cf unquote-splicing}, so they are not provided.

\item The \rsixrs~method of specifying mantissa widths was not adopted.

\end{itemize}

\subsection*{Incompatibilities with the \rsixrs\ Standard Libraries document}

This section enumerates the incompatibilities between \rsevenrs\ and
the \rsixrs~\cite{R6RS} Standard Libraries.

{\em This list is not authoritative, and is likely to be incomplete.}

\begin{itemize}

\item The low-level macro system and {\cf syntax-case} were not adopted. There
are two general families of macro systems in widespread use --- the
{\cf syntax-case} family and the {\cf syntactic-closures} family --- and they have
neither been shown to be equivalent nor capable of implementing each
other. Given this situation,
low-level macros have been left to the large language.

\item The new I/O system from \rsixrs{} was not adopted. 
Historically, standardization reflects technologies that have undergone
a period of adoption, experimentation, and usage before incorporation
into a standard.  The Working Group was
unhappy with the redundant
provision of both the new system and the \rfivers{}-compatible ``simple I/O''
system.
However, binary I/O was added using binary ports that are
at least potentially disjoint from
textual ports and use their own parallel set of procedures.

\item String ports are compatible with SRFI 6 rather than \rsixrs; analogous
bytevector ports are also provided.

\item The Working Group felt that the \rsixrs{} records system was overly complex, and the two layers
poorly integrated. The Working Group spent a lot of time debating this, but in the
end decided to simply use a generative version of SRFI 9, which has
near-universal support among implementations. The Working Group hopes to provide a more
powerful records system in the large language.

\item \rsixrs{}-style bytevectors are included, but provide only the ``u8'' procedures in the small
language.  The lexical syntax uses {\cf \#u8} for compatibility
with SRFI 4, rather than the \rsixrs~{\cf \#vu8} style.
With a library system, it's easier to change names than reader syntax.

\item The utility macros {\cf when} and {\cf unless} are provided, but since it would be
meaningless to try to use their result, it is left unspecified.

\item The Working Group could not agree on a single design for hash tables and left them for
the large language. 

\item Sorting, bitwise arithmetic, and enumerations were not considered to be
sufficiently useful to include in the small language.  They will probably be
included in the large language.

\item Pair and string mutation are too well-established to be relegated to
separate libraries.

\end{itemize}

