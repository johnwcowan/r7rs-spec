\extrapart{Notes}


\todo{Perhaps this section should be made to disappear.
Can these remarks be moved somewhere else?}

\subsection*{Language changes}
\label{differences}

This section enumerates the changes that have been made to Scheme since
the ``Revised$^5$ report''~\cite{R5RS} was published.

{\em While this report is in draft status the list should be considered incomplete and subject to change.}

\begin{itemize}

\item Modules have been added as a new program structure to improve
encapsulation and sharing of code.  Some existing and new identifiers
have been factored out into separate modules.

\item Exceptions can now be signalled explicitly with {\cf raise},
{\cf raise-continuable} or {\cf error}, and can be handled with {\cf
with-exception-handler} and the {\cf guard} syntax.

\item New disjoint types supporting access to multiple fields can be
generated with {\cf define-record-type}.

\item Parameter objects can be created with {\cf make-parameter}, and
dynamically rebound with {\cf parameterize}.

\item {\em Blobs}, homogeneous vectors of integers in the range
$[0..255]$, have been added as a new disjoint type.

\item {\em Ports} can now be designated as {\em binary} or {\em
character} ports, with new procedures for reading and writing binary
data.

\item {\em String ports} have been added as a way to write characters
to and read characters from strings.

\item {\cf Current-input-port} and {\cf current-output-port} are now
parameter objects, along with the newly introduced {\cf
current-error-port}.

\item {\cf Syntax-rules} now recognizes {\em \_} as a wildcard, allows
the ellipsis symbol to be specified explicitly instead of the default
{\cf ...}, allows template escapes with an ellipsis-prefixed list, and
allows tail patterns to follow an ellipsis pattern.

\item {\cf Syntax-error} has been added as a way to signal immediate
and more informative errors when a form is expanded.

\item Internal {\cf define-syntax} forms are now allowed preceding any
internal {\cf define}s.

\item {\cf Letrec*} has been added, and internal define specified in
terms of it.

\item {\cf Case} now supports a {\tt =>} syntax analagous to {\cf cond}.

\item {\cf Case-lambda} has been added to the base module as a way to
dispatch on the number of arguments passed to a procedure.

\item Positive and negative infinity and a NaN object have been added
to the numeric tower as inexact values with the written
representations {\tt +inf.0}, {\tt -inf.0} and {\tt +nan.0},
respectively.

\item {\cf Map} and {\cf for-each} are now required to terminate on
the shortest list when inputs have different length.

\item {\cf Member} and {\cf assoc} now take an optional third argument
for the equality predicate to use.

\item {\cf Exact-integer?}\  and {\cf exact-integer-sqrt} have been added.

\item {\cf Make-list}, {\cf copy-list}, {\cf list-set!}, {\cf
string-map}, {\cf string-for-each}, {\cf string->vector}, {\cf
copy-vector}, {\cf vector-map}, {\cf vector-for-each}, and {\cf
vector->string} have been added to round out the sequence operations.

\item The set of characters used is required to be consistent with the
latest Unicode standard only in so far as the implementation supports
Unicode.

\item {\cf string-ni=?} and related procedures have been added to
compare strings as though they had gone through an
implementation-defined normalization, without exposing the
normalization.

\item The case-folding behavior of the reader can now be explicitly
controlled, with no folding as the default.

\item The reader now recognizes the new comment syntax {\tt \#;} to
skip the next datum, and allows nested block comments with
{\tt \#| ... |\#}.

\item Data prefixed with reader labels {\tt \#<n>=} can be referenced
with {\tt \#<n>\#} allowing for reading and writing of data with
shared structure.

\item Strings and symbols now allow mnemonic and numeric escape
sequences, and the list of named characters has been extended.

\item {\cf File-exists?}\ and {\cf delete-file} are available in the
{\tt (scheme file)} module.

\item An interface to the system environment and command line is
available in the {\tt (scheme process-context)} module.

\item Procedures for accessing the current time are available in the
{\tt (scheme time)} module.

\item A complete set of integer division operators is available in the
{\tt (scheme division)} module.

\item {\cf Transcript-on} and {\cf transcript-off} have been removed.

\end{itemize}

%% \begin{itemize}

%% \item The report is now a superset of the IEEE standard for Scheme
%% \cite{IEEEScheme}: implementations that conform to the report will
%% also conform to the standard.  This required the following changes:
%% \begin{itemize}

%% \item The empty list is now required to count as true.

%% \item The classification of features as essential or inessential has been
%% removed.  There are now three classes of built-in procedures: primitive,
%% library, and optional.  The optional procedures are {\cf load},
%% {\cf with-input-from-file}, {\cf with-output-\linebreak[0]to-file},
%% {\cf transcript-\linebreak[0]on}, {\cf transcript-\linebreak[0]off}, and
%% {\cf interaction-\linebreak[0]environment},
%% and {\cf -} and {\cf /} with more than two arguments.
%% None of these are in the IEEE standard.

%% \item Programs are allowed to redefine built-in procedures.  Doing so
%% will not change the behavior of other built-in procedures.
%% \end{itemize}

%% \item {\em Port} has been added to the list of disjoint types.

%% \item The macro appendix has been removed.  High-level macros are now part
%% of the main body of the report.  The rewrite rules for derived expressions
%% have been replaced with macro definitions.  There are no reserved identifiers.

%% \item {\cf Syntax-rules} now allows vector patterns.

%% \item Multiple-value returns, {\cf eval}, and {\cf dynamic-wind} have
%% been added.

%% \item The calls that are required to be implemented in a properly tail-recursive
%% fashion are defined explicitly.

%% \item `{\cf @}' can be used within identifiers. `{\cf \verb"|"}' is reserved
%% for possible future extensions.

%% \end{itemize}

%%R4%%
%\subsection*{Keywords as variable names}
%
%Some implementations allow arbitrary syntactic
%keywords \index{keyword}\index{syntactic keyword}to be used as variable
%names, instead of reserving them, as this report would have
%it.\index{variable} But this creates ambiguities in the interpretation
%of expressions: for example, in the following, it's not clear whether
%the expression {\tt (if 1 2 3)} should be treated as a procedure call or
%as a conditional.
%
%\begin{scheme}
%(define if list)
%(if 1 2 3)    \ev  2 {\em{}or} (1 2 3)%
%\end{scheme}
%
%These ambiguities are usually resolved in some consistent way within any
%given implementation, but no particular treatment stands out as being
%clearly superior to any other, so these situations were excluded for the
%purposes of this report.

%%R4%%
%\subsection*{Macros}
%
%Scheme does not have any standard facility for defining new kinds of
%expressions.\index{macros}
%
%\vest The ability to alter the syntax of the language creates
%numerous problems.  All current implementations of Scheme have macro
%facilities that solve those problems to one degree or another, but the
%solutions are quite different and it isn't clear at this time which
%solution is best, or indeed whether any of the solutions are truly
%adequate.  Rather than standardize, we are encouraging implementations
%to continue to experiment with different solutions.
%
%\vest The main problems with traditional macros are: They must be
%defined to the system before any code using them is loaded; this is a
%common source of obscure bugs.  They are usually global; macros can be
%made to follow lexical scope rules \todo{flushed: ``as in Common
%Lisp's {\tt macrolet}''; OK?}, but many people find the resulting scope rules
%confusing.  Unless they are written very carefully, macros are
%vulnerable to inadvertent capture of free variables; to get around this,
%for example, macros may have to generate code in which procedure values
%appear as quoted constants.  There is a similar problem with syntactic
%keywords if the keywords of special forms are not reserved.  If keywords
%are reserved, then either macros introduce new reserved words,
%invalidating old code, or else special forms defined by the programmer
%do not have the same status as special forms defined by the system.
%
%\todo{Refer to Pitman's special forms paper.}
%\todo{Pitman sez: Discuss importance of having a small number of special forms
%so that programs can inspect each other.}

%% \todo{Move cwcc history back here? --- Andy Cromarty is concerned about
%% confusion over who the audience is.}

%% \todo{Cromarty:
%% 23. NOTES, p.35ff.: This material should stay somehow.  We need to
%%     make it clear that R$^3$ Scheme is not being touted as Yet Another
%%     Ultimate Solution To The Programming Language Problem, but rather
%%     as a snapshot of a *process* of good design, for which not all
%%     answers have yet been found.  We also ought to use the opportunity
%%     for publicity afforded us by SIGPLAN to advertise some of the thorny
%%     unsolved problems that need further research, and encourage
%%     language designers to work on them.}
